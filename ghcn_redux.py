# -*- coding: utf-8 -*-
"""GHCN_redux.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oVdgapRrH6Glbi-62WizjNo4Ph96D8Ln

# Machine Learning Mini Project : Weather and Climate Prediction
---

Completed 05-01-2021

---


# 1. Introduction

The first (compulsory) purpose of this notebook is to attempt to build usable predictive models of the weather at specific locations around the Earth. Throughout this section, the metrics assessed are the minimum / maximum temperatures (TMIN, TMAX), the precipitation level (PRCP) and, where possible, snow depth (SNWD). These were selected, as the first three were fairly universal between stations, while many other metrics proved to be either unmeasured, or too intermittent to be useful. 

This section is divided into three main tasks:

1. Build a model to predict TMIN, TMAX, PRCP and SNWD 30 days in advance, covering the period from October 2020 onwards.
2. Build another model, this time to predict monthly averages, a year in advance.
3. Try to build a model that can predict the next day's weather with better accuracy than simply assuming it will be the same as the day before. 

In addition, two extensions were undertaken

1. In this notebook: Interactive historical / predicted global Earth climate map from 1950 - 2040
2. In the `NASA_insight` notebook: Functional predictive models of Martian weather systems using data from NASA's InSight Lander

The first is an interactive temperature map of the world, using the monthly average of all 990 stations. This ingests all historical data (1950-2020), and uses a climate model to predict out to 2040. This is aggregated and made into a heatmap, allowing for each month to be studied, providing statistics on the hottest and coldest station in each case.

The second extension is arguably more interesting, retrieving the complete (~535 sols thus far) mission data from the NASA InSight Mars lander, and builds accurate predictive models of temperature, wind speed and direction. This allows for accurate hourly predictions of weather, as well as accurate 30-day temperature predictions. While not strictly using GHCND data, it was deemed similar enough in scope to be included.

__The text in these notebooks exclusively exists as annotations to help follow the code - for analysis and commentary on the results, see the full report.__

__Additionally, note that the data preparation for the interactive map, predicting the weather at all 990 stations, takes up to 25 minutes even with a GPU. Screenshots from it are included in the section as a time saver, if preferable.__

# 2. Setup

## 2.1 Imports
---
First, the standard modules are imported, with one or two additions. In addition to Numpy, Tensorflow and Keras, the warnings and ipywidgets modules are included. Warnings were included to suppress two edge cases, specifically related to ragged arrays. This only presented an issue during the first extension task, where stations had varying amounts of monthly data, meaning the aggregated data array was ragged, thus throwing a warning. ipywidgets were included for the same task, so that a slider could be used to control the date for the map
"""

#Standard imports
import urllib
from datetime import *
import numpy as np
import matplotlib.pyplot as plt 
import tensorflow as tf
import math
from tensorflow import keras

#Import warnings and ipywidgets for the climate map
import warnings
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets

#Suppress specific warnings to prevent cluttering the output
tf.get_logger().setLevel('ERROR')
warnings.filterwarnings("ignore", category=DeprecationWarning)            
warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)

"""## 2.2 GHCND functions
---
These were provided with the task notebook, and are responsible for processing the GHCND datasets into enumerable formats for later. There is an unhandled exception in the `GHNCD.getVar()` method.

```
for month in statDict[varName]['monthList']
```
This will raise a `KeyError` if a station doesn't have the requested `varName`. 
This was left unchanged, specifically because this error later allows for incomplete data to be excluded from the climate map, and because there are enough mitigation methods in place to control it, especially the lack of user input.
"""

#Class that keeps information about station name and location
class Station():
    def __init__(self,sid,lat,lon,el,state,name,gsn,hcn,wmo,country):
        self.sid=sid
        self.lat=lat
        self.lon=lon
        self.el=el
        self.state=state
        self.name=name
        self.gsn=gsn
        self.hcn=hcn
        self.wmo=wmo
        self.country=country
        
    def __str__(self):
        return self.sid+" is "+self.name+", "+self.country+" at "+str(self.lat)+", "+str(self.lon)+", "+str(self.el)

#Class that hides some ugly reading routines
class GHNCD:
     
    #Class constructor
    def __init__(self): 
        self.station_col_len = [11,4,2,4]
        for i in range(31):
            self.station_col_len.append(5)
            self.station_col_len.append(3)
    
    # Split up the fixed length text arrays into fields
    def chunkstring(self,string, lengths):
        return (string[pos:pos+length].strip() 
                for idx,length in enumerate(lengths)
                for pos in [sum(map(int, lengths[:idx]))])

    # Process a file and extract all the information into a dictionary
    def processFile(self,fileName):
        outDict={} #
        with open(fileName, 'r') as fp: # Open file
            line = fp.readline()  #Read first line
            while line: # Process line
                fields = list(self.chunkstring(line, self.station_col_len)) #Get list of fields
                
                # For clarity use some variable names
                station=fields[0]  
                year=int(fields[1])
                month=int(fields[2])
                field=fields[3]
                vals=fields[4::2]
                flags=fields[5::2]
                # Not clear this is the only check we need, but for now
                def checkInt(x,flag):
                    if flag=='':
                        return -9999
                    return int(x)
                
                #Convert missing entries to -9999 using this swishy bit of string comprehension
                ivals=[checkInt(x,flag) for (x,flag) in zip(vals,flags)]
                monthDict=dict(year=year,month=month,field=field,vals=ivals,flags=flags)
                if field in outDict.keys():
                    outDict[field]['monthList'].append(monthDict)
                else:
                    fieldDict=dict(monthList=[monthDict])
                    outDict[field]=fieldDict
                line = fp.readline()
        return dict(outDict) #Return a copy
    
    def readCountriesFile(self,fileName=None):
        self.countryDict={}
        if fileName==None:
            file = urllib.request.urlopen('http://www.hep.ucl.ac.uk/undergrad/0056/other/projects/ghcnd/ghcnd-countries.txt')
        else:
            file = open(fileName,'r')
        
        for line in file:
            c=str(line[0:2], 'utf-8')
            d=str(line[3:-2], 'utf-8')                  
            self.countryDict[c]=d
        print("Read",len(self.countryDict),"countries and codes")
        
    
    def readStationsFile(self,fileName=None,justGSN=True):
        
        #------------------------------
        #Variable   Columns   Type
        #------------------------------
        #ID            1-11   Character
        #LATITUDE     13-20   Real
        #LONGITUDE    22-30   Real
        #ELEVATION    32-37   Real
        #STATE        39-40   Character
        #NAME         42-71   Character
        #GSN FLAG     73-75   Character
        #HCN/CRN FLAG 77-79   Character
        #WMO ID       81-85   Character
        #------------------------------
        self.stationDict={}
        if fileName==None:
            file = urllib.request.urlopen('http://www.hep.ucl.ac.uk/undergrad/0056/other/projects/ghcnd/ghcnd-stations.txt')
        else:
            file = open(fileName,'r')
        
        for line in file:
            sid=str(line[0:11], 'utf-8')
            lat=float(str(line[12:20], 'utf-8'))
            lon=float(str(line[21:30], 'utf-8'))
            el=float(str(line[31:37], 'utf-8'))
            state=str(line[38:40], 'utf-8')
            name=str(line[41:71], 'utf-8')
            gsn=str(line[72:75], 'utf-8')
            hcn=str(line[76:79], 'utf-8')
            wmo=str(line[80:85], 'utf-8')
            
           
            if justGSN:
                if gsn=='   ':
                    continue
            self.stationDict[sid]=Station(sid,lat,lon,el,state,name.rstrip(),gsn,hcn,wmo,self.countryDict[sid[0:2]])
        print("Read",len(self.stationDict),"stations with justGSN",justGSN)

    # Get all the data for a given variable type
    def getVar(self,statDict,varName='TMAX'):
        #The TMIN, TMAX, PRCP are all quoted in tenths (so need to be multipied by 0.1)
        cal=0.1
        if varName=='SNOW' or varName=='SNWD':
            cal=1.0
        tempList=[ (date(month['year'],month['month'],ind+1),cal*val)  for month in statDict[varName]['monthList'] for ind, val in enumerate(month['vals']) if val!=-9999   ] #Potential KeyError if invalid varName
        return tempList
    
    def getTMAX(self,statDict):
        return self.getVar(statDict,'TMAX')
    
    def printStation(self,sid):
        print(self.stationDict[sid])
        
    def getStation(self,sid):
        return self.stationDict[sid]
        
    def getStatKeyNames(self):
        #print(self.stationDict.keys())
        return [*self.stationDict.keys()]

"""Again, this is from the basic task script, and initialises the `ghn` object, which can be used later to retrieve station-specific data."""

#Initialise the ghn object, and parse in the data
ghn=GHNCD()
ghn.readCountriesFile()
ghn.readStationsFile()

# Get list of station names
statNames=ghn.getStatKeyNames()

"""## 2.3 Data sanitisation and formatting
---
Here, two functions are defined:

`getWindow1D` is relatively trivial, constructing arrays representing slices of a linear array, to allow training batches to be made for simple datasets.

`getSequentialDatapoints` is likely the most important function for this section, and is responsible for correctly formatting the weather data, as well as accounting for the myriad missing datapoints. The networks require consecutive days' weather measurements to be inputted to allow for a valid prediction. However, not all days have all the measurements, and at times whole days are lacking measurements.

To account for this, the function first excludes days where the requested values (e.g TMIN, TMAX, PRCP and SNWD) weren't all measured. Next, it iterates over the data and constructs arrays of `windowSize` consecutive days. Lastly, these batches, representing the training inputs, are limited to those with valid labels / outputs. For a 30 day prediction, the array is checked to see if a measurement was made 30 days later that can be used as a label. If not, the code can search within a specified interval `maxPredError` for a "close enough" estimate. 

This method ensures that the training data is correct, and that a given training input does indeed result in its label (rather than having data where the inputs are in fact several days apart, or the label is on the other side of a one month gap in measurements). 
"""

def getWindow1D(inData, windowsize):
  '''
  Builds an array of windows from a given input array.

  Inputs:
  inData (ARR)
                  1D array of values
  windowSize (INT)
                  the width of a window in elements

  Returns:
                  An array of windows, each of size windowSize.
  '''
  data = []
  for i in range(0, len(inData)-windowsize):
    data.append(np.array(inData[i:i+windowsize]))
  return np.array(data).astype(np.float32)

def getSequentialDatapoints(whichStat, dataKeys=['TMAX', 'TMIN', 'PRCP', 'SNWD'], windowSize=10, maxTimeInterval=3, predTime=30, maxPredError=0, normalise=True, targetMonths=range(1,13)):
    '''
    Takes four measurement types and produces a cohesive dataset, excluding missing measurements or large leaps in time. 
    Data that fails to satisfy the parameters is discarded entirely.
  
    Inputs:
    
    whichStat (INT)
                0-990, integer identifier for the station to get data from 

    windowSize (INT)
                The number of sequential measurements to place in each set of training data. Higher windowsizes may result
                in lower overall training inputs returned, as the chance of a larger window having at least one gap in 
                measurments is higher.
                 
    maxTimeInterval (INT)
                The maximum time (in days) allowable between measurements. Setting this to 1 means there can be no
                gap in measurementes (as every measurement must be the 1 day after the previous). Lower values will reduce
                dataset size, but result in higher quality training data.
                
    predTime (INT)
                How many days into the future to predict
                
    maxPredError (INT)
                If there isn't a measurment exactly (predTime) days into the future, how many days before or after that date
                is the function allowed to look to find a "close enough" prediction.
                
    Returns:
    
    dataSequences (ARR)
                The training inputs in the shape (num inputs, window size, 4). Essentially an array of windows, the elements
                of which are 4-vectors containing each of the measurements on that day. 
                
    predictionValues (ARR)
                The predictions for the training inputs, of shape (num inputs, 4).

    dates (ARR)
                The dates of the labels (predictionValues), of shape (numInputs, 1)
    
    means, stds (ARR)
                The means and standard deviations of each parameter, both shape (4)
    
    '''

    #Get the filename for this station
    fileName=statNames[whichStat]+'.dly'
    urlName='http://www.hep.ucl.ac.uk/undergrad/0056/other/projects/ghcnd/ghcnd_gsn/'+fileName

    #Download and process the data
    urllib.request.urlretrieve(urlName,fileName)
    statDict=ghn.processFile(fileName)
    print(ghn.getStation(statNames[whichStat]))

    #Get the arrays of measurements. These names are purely illustrative.
    tmaxArray=np.array(ghn.getVar(statDict,dataKeys[0]))
    tminArray=np.array(ghn.getVar(statDict,dataKeys[1]))
    prcpArray=np.array(ghn.getVar(statDict,dataKeys[2]))
    snowArray=np.array(ghn.getVar(statDict,dataKeys[3]))


    #Convert them to dictionaries so we can retrieve values by date
    tmaxDict = dict(tmaxArray)
    tminDict = dict(tminArray)
    snowDict = dict(snowArray)
    prcpDict = dict(prcpArray)

    #List for storing all the overlapping measurements
    combArray = []

    #Iterate over the tmax array, and if all four measurements were taken on that day, save their results into the array
    #along with the date
    for i in range(0, len(tmaxArray)):
        x = tmaxArray[i][0]
        if (x in tminArray[:,0] and x in snowArray[:,0] and x in prcpArray[:,0]):
          if x.month in targetMonths:
            combArray.append([x, tmaxDict[x], tminDict[x], prcpDict[x], snowDict[x]])

    #Cast to an np array
    combArray = np.array(combArray)
    
    #Iterate over the dates, and save the same array again, but with the time since last measurement instead of the date
    timeDeltas = []
    for i in range(1, len(combArray)):
        timeDeltas.append([(combArray[i][0] - combArray[i-1][0]).days, *combArray[i][0:]])
    timeDeltas = np.array(timeDeltas)
    
    #Variables for storing the input sequence (historical data) and the result (the measurements at some point in the future)
    dataSequences = []
    predictionValues = []
    dates = []

    #Iterate through the data
    for i in range(0, len(timeDeltas)-windowSize-predTime):
        
        #Select a set of (windowSize) data points and get their time offsets from each other
        sequence = list(timeDeltas[i:i+windowSize,0])
        
        #Search for a close prediction value
        if(max(sequence) <= maxTimeInterval):
            
            #How many days into the future the time deltas add up to for a certain data point
            cumulativeOffset = 0

            #Iterate over the next few measurements, to see which is closest to predTime
            for t in range(1, predTime+1):
                
                #Save the previous offset
                priorOffset = cumulativeOffset
                
                #Add the delta T to the offset for the next datapoint (summing the deltas gives the total time into the future)
                cumulativeOffset += timeDeltas[i+windowSize+t][0]
                
                #If we're bang on, save the input sequence and the prediction and quit the loop
                if cumulativeOffset == predTime:
                    predictionValues.append(timeDeltas[i+windowSize+t][2:])
                    dataSequences.append(timeDeltas[i:i+windowSize,2:])
                    dates.append(timeDeltas[i+windowSize+t,1])
                    break
                    
                #Otherwise, chose the closest (within reason) value on either side.
                else:
                     if(cumulativeOffset > predTime and priorOffset < predTime):
                            currDiff = cumulativeOffset - predTime
                            priorDiff = predTime - priorOffset

                            #If this is closer to the prediction time and within the error
                            if (currDiff < priorDiff and currDiff <= maxPredError):
                                predictionValues.append(timeDeltas[i+windowSize+t][2:])
                                dataSequences.append(timeDeltas[i:i+windowSize,2:])
                                dates.append(timeDeltas[i+windowSize+t,1])            #NOTE THAT THE RETURNED DATES ARE THE DATES OF THE PREDICTIONS
                                break
                            
                            #If the previous one is closer and within the error
                            elif (priorDiff < currDiff and priorDiff <= maxPredError):
                                predictionValues.append(timeDeltas[i+windowSize+t-1][2:])
                                dataSequences.append(timeDeltas[i:i+windowSize,2:])
                                dates.append(timeDeltas[i+windowSize+t,1])
                                break
                            
                            #Otherwise both measurements are invalid
                            else:
                                break
                                
    #Retype the arrays as float32s to prevent tensorflow type errors
    predictionValues= np.array(predictionValues).astype(np.float32)                          
    dataSequences=np.array(dataSequences).astype(np.float32)

    #Lists to store the means and standard deviations of the sequences
    means = []
    stds = []

    #Normalise the data (if requested)
    for i in range(0, 4):
      mean = np.mean(dataSequences[:,:,i].flatten())
      std = np.std(dataSequences[:,:,i].flatten())
      if normalise:
        dataSequences[:,:,i] -= mean
        dataSequences[:,:,i] /= std
        predictionValues[:,i] -= mean
        predictionValues[:,i] /= std 
      means.append(mean)
      stds.append(std)

    dates = np.array(dates)

    #Return the training batches, labels, the dates of the labels, and means / standard deviations
    return dataSequences, predictionValues, dates, means, stds

"""## 2.4 Model definitions and training functions
---
Four template models are used for the weather and climate predictions. The first two are single-input single-output, with the `alt` versions being significantly less complex. The same is true of the dual-input dual-output networks, where the `alt` version lacks many of the layers of the other. This was done to allow networks of appropriate complexity to be used for each task in order to save computation time.

Two functions,`trainModel1D` and `trainModel2D` are defined for building and training new models of different dimensionalities, as well of varying complexity. This was done to simplify the number of function calls made later.
"""

def getModel1D():
    '''
    Returns an unfitted LSTM model with Two hidden layers, one LSTM and one Dense
    
    '''
    model=keras.models.Sequential()
    model.add(keras.layers.LSTM(32,input_shape=(None,1),return_sequences=False))
    model.add(keras.layers.Dense(20,activation="linear"))
    model.add(keras.layers.Dense(1,activation="linear"))

    model.compile(loss='mean_absolute_error',optimizer='adam')
    return model

def getModel1D_alt():
    '''
    Returns an unfitted LSTM model with a single LSTM hidden layer
    
    '''
    model=keras.models.Sequential()
    model.add(keras.layers.LSTM(8,input_shape=(None,1),return_sequences=False))
    model.add(keras.layers.Dense(1,activation="linear"))

    model.compile(loss='mean_absolute_error',optimizer='adam')
    return model



def getModel2D():
    '''
    Returns an unfitted dual input network with several LSTM layers
    
    '''
    model=keras.models.Sequential()
    model.add(keras.layers.LSTM(128,input_shape=(None,2),return_sequences=True))
    model.add(keras.layers.LSTM(64,return_sequences=True))
    model.add(keras.layers.LSTM(128,return_sequences=True))
    model.add(keras.layers.LSTM(64,return_sequences=False))
    model.add(keras.layers.Dense(64, activation="linear"))
    model.add(keras.layers.Dense(2,activation="linear"))

    model.compile(loss='mean_absolute_error',optimizer='adam')
    return model


def getModel2D_alt():
  '''
  Returns an unfitted dual input network with two LSTM and one dense layer
  
  '''
  model=keras.models.Sequential()
  model.add(keras.layers.LSTM(64,input_shape=(None,2),return_sequences=True))
  model.add(keras.layers.LSTM(32,return_sequences=False))
  model.add(keras.layers.Dense(8, activation="linear"))
  model.add(keras.layers.Dense(2,activation="linear"))

  model.compile(loss='mean_absolute_error',optimizer='adam')
  return model


def trainModel2D(trainData, trainLabels, splitIndex, validationRatio, N_batches, N_epochs, alt=False, verb=0):
  '''
  Trains a dual-input model on a given set of data, with customisable ratios for training and valdation.

  Inputs

  trainData (ARR)
              The data to use for the fitting (training and validation), shape (batches, windowsize, 2)
  
  trainLabels (ARR)
              The labels for the data, shape (batches, 2)

  splitIndex (INT)
              The index of the last datapoint to use (the end of the validation array), marking where the test data starts
  
  validationRatio (FLOAT)
              The fraction of the training data to use as validation data

  N_batches, N_epochs (INT)
              The batchsize and number of training epochs to use in fitting respectively

  alt (BOOL)
              Boolean, whether to use the simpler model type
  
  verb (INT)
              Integer, set the verbosity level (0=silent, 1=verbose)
  '''
  weatherModel2D = None 
  if alt:
    weatherModel2D = getModel2D_alt()
  else:
    weatherModel2D = getModel2D()

  validationIndex = int(splitIndex * (1. - validationRatio))

  costs = weatherModel2D.fit(trainData[:validationIndex], trainLabels[:validationIndex], batch_size=N_batches, epochs=N_epochs, validation_data=(trainData[validationIndex:], trainLabels[validationIndex:]), verbose=verb)
  return weatherModel2D, costs


def trainModel1D(trainData, trainLabels, splitIndex, validationRatio, N_batches, N_epochs, alt=False, verb=0):
  '''
  Trains a single-input model on a given set of data, with customisable ratios for training and valdation.

  Inputs

  trainData (ARR)
              The data to use for the fitting (training and validation), shape (batches, windowsize, 2)
  
  trainLabels (ARR)
              The labels for the data, shape (batches, 2)

  splitIndex (INT)
              The index of the last datapoint to use (the end of the validation array), marking where the test data starts
  
  validationRatio (FLOAT)
              The fraction of the training data to use as validation data

  N_batches, N_epochs (INT)
              The batchsize and number of training epochs to use in fitting respectively

  alt (BOOL)
              Boolean, whether to use the simpler model type
  
  verb (INT)
              Integer, set the verbosity level (0=silent, 1=verbose)
  '''
  weatherModel1D = None
  if alt:
    weatherModel1D = getModel1D_alt()
  else:
    weatherModel1D = getModel1D()

  validationIndex = int(splitIndex * (1. - validationRatio))

  costs = weatherModel1D.fit(trainData[:validationIndex], trainLabels[:validationIndex], batch_size=N_batches, epochs=N_epochs, validation_data=(trainData[validationIndex:], trainLabels[validationIndex:]), verbose=verb)
  return weatherModel1D, costs

"""## 2.5 Auxiliary data handling functions
---
The final set of functions used for this section of analysis are a group of data processing functions, used for interpreting results rather than directly impacting their calculations.

`smoothData` applies a basic smoothing function, changing each value in an array to be the weighted mean of itself and the values on either side.

`comparePredictions` is a graphing function used for comparing values predicted by a model to the "true" ones.
"""

def smoothData(data, width, weight):
  '''
  Averages datapoints to include the values of their neighbours

  Inputs:

  data (ARR)
              The input data to smooth
  
  width (INT)
              The number of values on either side to average across
  
  weight (FLOAT)
              How much to weight the values on either side (likely less than zero)

  Outputs:

  ret (ARR)
              The smoothed array
  '''

  ret = []
  for i in range(0, width):
    ret.append(data[i])
  for i in range(width, len(data) - width):
    ret.append((sum(data[i-width:i])*weight + data[i] + weight*sum(data[i+1:i+width]))/(1+2*width) )
  ret = np.array(ret)
  return ret

def comparePredictions(model, testData, testLabels, predictionDates, axislabels=[], plottitles=[], useAltTestData=False, altTestData=None, altDates=None):
  '''
  Compare the predictions of a 2D model on a a given set of data to the actual values

  Inputs:
  
  model (NN)
              The trained network to use for the predictions

  testData, testLabels (ARR)
              The input data and the correct prediction values
    
  predictionDates (ARR)
              The dates that the predicted values correspond to, useful for correctly aligning the values on the x axis
  
  useAltTestData (BOOL)
              Whether some extra prediction data is supplied to predict on, useful for comparing values predicted on the true inputs,
              and the values predicted using the outputs of some other model at the same time
  
  altTestData (ARR)
              The alternate input set to use only used if useAltTestData is True
  
  altDates (ARR)
              The array of dates that the alternate test data corresponds to

  Outputs:
             Two or three subplots showing the predictions of the network compared to the real values 
  '''
  #Predict using the input data
  predictions = model.predict_on_batch(testData)
  altPredictions = None

  #If alternate data has been supplied, add an extra subplot to the total to make
  #and predict on the alternate data too
  if useAltTestData:
    altPredictions = model.predict_on_batch(altTestData)

  #Plot the real data, data predicted on the test inputs, and data predicted on the alt. inputs
  fig, ax = plt.subplots(1,2, figsize=(30,6))

  ax[0].plot(predictionDates, testLabels[:,0], 'b--', label="Actual")
  ax[0].plot(predictionDates, predictions[:,0], 'b-', label="Predicted")
  ax[0].set_xlabel(axislabels[0])
  ax[0].set_ylabel(axislabels[1])
  ax[0].set_title(plottitles[0])

  if useAltTestData:
    ax[1].plot(predictionDates, testLabels[:,1], 'r--', label="Actual")
    ax[1].plot(altDates, altPredictions[:,1], label="Predicted")
    ax[1].set_xlabel(axislabels[0])
    ax[1].set_ylabel(axislabels[1])
    ax[1].set_title(plottitles[1])
  else:
    ax[1].plot(predictionDates, testLabels[:,1], 'r--', label="Actual")
    ax[1].plot(predictionDates, predictions[:,1], 'r-', label="Predicted")
    ax[1].set_xlabel(axislabels[0])
    ax[1].set_ylabel(axislabels[1])
    ax[1].set_title(plottitles[1])
  ax[0].legend()
  ax[1].legend()
  return

"""# 3. Predicting 30 days into the future

## 3.1 Approach
---
Here, the selected station was ID#201, located in Canada. This was chosen as it had temperature, precipitation and snow depth data, as well as an acceptable number of missing values. A layered approach is used, in the following order:

1. Train a model to predict TMAX and TMIN 30 days in advance
2. Train models to use TMAX and TMIN to predict the next days PRCP and SNWD
3. Use the temperature model to predict 30 days into the future
4. Use the PRCP / SNWD model to convert the temperature predictions into precipitation and snow predictions

This was done specifically to avoid issues caused by spotty PRCP / SNWD data, which wasn't measured regularly, preventing a full TMAX+TMIN+PRCP+SNWD four-input model from being a viable solution. Instead, this more general approach made better use of the available data, and allowed for generic predictions to be made given any set of temperature values.

## 3.2 Temperature modelling
---
First, the temperature-only data is retrieved from the database. The parameters `["TMAX", "TMIN", "TMAX", "TMIN"]` are supplied to the `getSequentialDatapoints` function to get data for predicting TMAX / TMIN using TMAX and TMIN as inputs. As the temperature data is relatively abundant, the training data is limited to the August-December period to get better predictions of autumnal / winter temperature variations. 

Training window sizes of 9 days are used, with a maximum time between measurements of 2 days, and a prediction time of 30 days.
"""

temp_ins, temp_outs, temp_in_dates, temp_means, temp_stds =  getSequentialDatapoints(201, dataKeys=["TMAX", "TMIN", "TMAX", "TMIN"], windowSize=9,maxTimeInterval=2, predTime=30, maxPredError=0, normalise=True, targetMonths=range(8, 13))

"""As the task specifically requests that the training set be up to the end of September 2020, the dataset is iterated over to find the index of the first value after 30-09-2020, denoting the beginning of the test data."""

tempSplitIndex = 0
tempFinalPredictionDate = date(2020,9,30)

#Iterate over the data and find the beginning of the test data
for i in range(0, len(temp_in_dates)):
  if temp_in_dates[i] >= tempFinalPredictionDate:
    tempSplitIndex = i
    break

"""Next, a model is trained on the data over 250 epochs, using a batch size of 100 windows. 20% of the dataset is set aside for validation. The loss and validation lost are shown below."""

#Train a dual input model to predict the temperature
tempModel2D, tempCosts = trainModel2D(temp_ins[:,:,:2], temp_outs[:,:2], tempSplitIndex, 0.2, 100, 250, verb=0) #250 is a good value

plt.figure(figsize=(10,5))
plt.title("Training and validation loss for the TMAX-TMIN model")
plt.plot(tempCosts.history["loss"], label="Train loss")
plt.plot(tempCosts.history["val_loss"], label="Valid loss")
plt.ylabel("Mean absolute error")
plt.xlabel("Epoch")
plt.legend()

"""With the model now trained, it can be fed to the `comparePredictions` function to show the difference between predicted and actual temperatures. """

temp_axlabels = ["Date", "Normalised temperature"]
temp_titles = ["Predicted vs Actual TMAX", "Predicted vs Actual TMIN"]
comparePredictions(tempModel2D, temp_ins[tempSplitIndex:,:,:2], temp_outs[tempSplitIndex:,:2], temp_in_dates[tempSplitIndex:], temp_axlabels, temp_titles)

"""## 3.3 Precipitation modelling using temperature
---
Next, this process is repeated, except that the labels/outputs are reconfigured to be the precipitation level rather than the temperature. Another dual-input model is trained on this data, with the aim of predicting the rainfall using the maximum and minimum temperature. This doesn't need to predict 30 days in advance, as it is used for translating temperature data into rainfall, so a small window size and a prediction time of 1 day is used instead.
"""

#Get data with TMAX and TMIN as the training parameters, and both outputs as PRCP
prcp_ins, prcp_outs, prcp_in_dates, prcp_means, prcp_stds =  getSequentialDatapoints(201, dataKeys=["TMAX", "TMIN", "PRCP", "PRCP"], windowSize=3,maxTimeInterval=2, predTime=1, maxPredError=1, normalise=True, targetMonths=range(1, 13))
prcpSplitIndex = 0

#As before, identify the test data splitting point
for i in range(0, len(prcp_in_dates)):
  if prcp_in_dates[i] >= tempFinalPredictionDate:
    prcpSplitIndex = i
    break

"""Again, the model is trained in the same way as the temperature model, and the training and validation lost is displayed below."""

#Train the precipitation model using this data
prcpModel2D, prcpCosts = trainModel2D(prcp_ins[:,:,:2], prcp_outs[:,2:], prcpSplitIndex, 0.2, 100, 250, verb=0)

#PLot the training and validation loss
plt.plot(prcpCosts.history["loss"], label="Training loss")
plt.plot(prcpCosts.history["val_loss"], label="Validation loss")
plt.title("Training and validation loss for the TEMP-PRCP model")
plt.ylabel("Mean absolute error")
plt.xlabel("Epoch")
plt.legend()

#Get the predicted temperature values, and predict the rainfall using those 
predictedTempTestData = getWindow1D(tempModel2D.predict_on_batch(temp_ins[tempSplitIndex:,:,:2]), 3)
predictedTempDates = temp_in_dates[tempSplitIndex+3:]+timedelta(1)

"""With the training complete, the same system of prediction comparisons is carried out. Here, the function is overridden using the `useAltTestData` switch, graphing the first prediction output and the data predicted using the alternate input. This is to allow for a comparison of the model predicting on real temperatures, and predictions using the 30-day forecasted data. """

#Graph the outputs of the network, along with the values derived from the predicted temperature
rain_axlabels = ["Date", "Normalised rainfall"]
rain_titles = ["Data predicted using actual temperature", "Data predicted using temperature model"]
comparePredictions(prcpModel2D, prcp_ins[prcpSplitIndex:,:,:2], prcp_outs[prcpSplitIndex:,2:], prcp_in_dates[prcpSplitIndex:], rain_axlabels, rain_titles, useAltTestData=True, altTestData=predictedTempTestData, altDates=predictedTempDates)

"""## 3.4 Snow depth modelling using temperature
---
Finally, an identical process to the precipitation modelling is carried out for the snow depth, using temperature as the predictor. Similar window sizes and prediction times are used to allow for the two models to be used side-by-side.
"""

#Get the data for temperature and snow depth modelling
snow_ins, snow_outs, snow_in_dates, snow_means, snow_stds =  getSequentialDatapoints(201, dataKeys=["TMAX", "TMIN", "SNWD", "SNWD"], windowSize=3,maxTimeInterval=2, predTime=1, maxPredError=1, normalise=True, targetMonths=range(8, 13))

#Find the splitting point
snowSplitIndex = 0
for i in range(0, len(snow_in_dates)):
  if snow_in_dates[i] >= tempFinalPredictionDate:
    snowSplitIndex = i
    break

#Train the model
snowModel2D, snowCosts = trainModel2D(snow_ins[:,:,:2], snow_outs[:,2:], snowSplitIndex, 0.2, 100, 250, verb=0)

#Plot the training and validation loss
plt.plot(snowCosts.history["loss"], label="Training loss")
plt.plot(snowCosts.history["val_loss"], label="Validation loss")
plt.title("Training and validation loss for the TEMP-SNWD model")
plt.ylabel("Mean absolute error")
plt.xlabel("Epoch")
plt.legend()

"""One final comparison is carried out here. As with the precipitation model, even predicting on the true data is relatively erroneous. However, this approach was used for its flexibility, enabling more data-agnostic predictions. This is the final model used for the 30-day predictions, as no other parameters were deemed suitable for analysis, due to the aforementioned issues with inconsistent and nonexistent data."""

#Predict the snowfall using the temperature, as with the precipitation
predictedTempTestData = getWindow1D(tempModel2D.predict_on_batch(temp_ins[tempSplitIndex:,:,:2]), 3)
predictedTempDates = temp_in_dates[tempSplitIndex+3:]+timedelta(1)

#Compare the three systems
snow_axlabels = ["Date", "Normalised snow depth"]
snow_titles = ["Data predicted using actual temperature", "Data predicted using temperature model"]
comparePredictions(snowModel2D, snow_ins[snowSplitIndex:,:,:2], snow_outs[snowSplitIndex:,2:], snow_in_dates[snowSplitIndex:], snow_axlabels, snow_titles, useAltTestData=True, altTestData=predictedTempTestData, altDates=predictedTempDates)

"""## 3.5 Semantic weather prediction using peak detection 
---
As is evident from the graphs, this method of prediction is far from accurate. The temperature prediction certainly predicts the approximate trend in values, and can identify the large dips. The same is true, albeit more extreme, for the precipitation and snow depth, where the network generates weak signals.

 Here, we see if we can use peak detection to estimate the weather qualitatively - to identify what days might have rain or snow, rather than determining exactly how much rain or snow there might be. This is especially useful for snow depth, as changes in snow depth indicate snowfall, which is a more useful weather metric for everyday usage.

Here, peaks are defined as points with higher values than those either side, or where the gradient is positive but decreasing. The `detectPeaks` function identifies these points and returns their dates.

The `matchPredictionPeaks` function uses this to identify peaks in the real and predicted values, and checks to find both matches, where peaks occur on the same day, partial matches (within one day of each other), and mismatches (no peak nearby). This is then displayed on a graph.
"""

def detectPeaks(inDates, inData, peakType="peak"):
  '''
  Given a 1D array, identifies maxima or minima in the values, returning the dates that these occur on

  Inputs:

  inDates [ARR]
          Array containing the dates that correspond to the input data
  
  inData  [ARR]
          Array containing the values to identify peaks in
  
  peakType [STRING]
          maximum or minimum, the type of peak to identify

  Outputs:

  peakDates [ARR]
          Array containing the dates on which peaks occur
  '''
  #Return variable for the dates
  peakDates = []

  #Iterate over the data and get the gradients between the current point
  #and the ones either side
  for i in range(1, len(inData)-1):
    grad1 = inData[i] - inData[i-1]
    grad2 = inData[i] - inData[i+1]

    #Check if this point is a peak, filtering out very small peaks (less than 0.05 change either side)
    if abs(grad1) > 0.05 or abs(grad2) > 0.05:
      if peakType == "peak":
        if grad1 > 0 and (grad2 > 0 or (grad2 < 0 and abs(grad2) < grad1)):
          peakDates.append(inDates[i])
      elif peakType == "ascend":
        if grad1 > 0:
          peakDates.append(inDates[i])

  #Return the dates
  return peakDates

def matchPredictionPeaks(baseDates, baseSeries, matchDates, matchSeries,maxError, mode, axislabels, plttitle, disp=True):
  '''
  Takes two sets of data, identifies the peaks in both and sees if any of them line up, returning
  the match rate.

  Inputs:
  baseDates, baseSeries [ARR]
            The dates and values of the first sequence to analyse

  matchDates, matchSeries [ARR]
            The dates and values of the second array to match to the first

  mode [STRING]
            Whether to search for the maxima or minima

  Returns:
  
  accuracy [FLOAT]
            The fraction of the peaks that match up

  '''

  #Arrays for storing matches in
  completeMatches = []
  falseMatches = []
  partialMatches = []

  #Min and max heights for the peak markers
  line_ymin = min(min(baseSeries), min(matchSeries))
  line_ymax = max(max(baseSeries), max(matchSeries))

  #Identify the peaks in each dataset
  basePeaks = detectPeaks(baseDates, baseSeries, peakType=mode)
  matchPeaks = detectPeaks(matchDates, matchSeries, peakType=mode)

  for peak in matchPeaks:

    viableDates = []
    for i in range(1, maxError):
      viableDates.append(peak+timedelta(i))
      viableDates.append(peak-timedelta(i))

    #Check for full matches
    if peak in basePeaks:
      completeMatches.append(peak)

    else:
      found = False

      #Search for peaks within the allowable forecast error
      for bp in basePeaks:
        if bp in viableDates and bp not in partialMatches and bp not in completeMatches:
          partialMatches.append(bp)
          found = True

      #If none found, count it as a mismatch
      if found == False:
        if peak < matchDates[-1] and peak > matchDates[0]:
          falseMatches.append(peak)


  if disp:
    #Draw the two data series, and mark the full, partial and mis- matches
    fig, ax = plt.subplots(1,1, figsize=(15,6))
    ax.set_title((plttitle + " +- " + str(maxError) + " days"))
    ax.set_xlabel(axislabels[0])
    ax.set_ylabel(axislabels[1])
    ax.plot(baseDates, baseSeries)
    ax.plot(matchDates, matchSeries)
    ax.set_xlim(matchDates[0], matchDates[-1])
    ax.vlines(completeMatches, line_ymin, line_ymax, 'green',linestyle="dashed")
    ax.vlines(partialMatches, line_ymin, line_ymax, 'orange', linestyle="dashed")
    ax.vlines(falseMatches, line_ymin, line_ymax, 'red', linestyle="dashed")
    
  #Calculate the ratio of matches to total peaks detected and return it
  accuracy = min(1, (len(completeMatches) + len(partialMatches))/(len(matchPeaks)))
  return accuracy

"""First, the predicted values for the precipitaion and snow depth were generated using the 30-day temperature predictions, using the keras `predict_on_batch` method."""

#Generate the predicted datasets
peakMatch_rainPreds = prcpModel2D.predict_on_batch(predictedTempTestData)[:,-1]
peakMatch_snowPreds = snowModel2D.predict_on_batch(predictedTempTestData)[:,-1]

"""Next, the values are run through the peak-detection functions, and aligned using `matchPredictionPeaks'. This allows for some basic accuracy metrics to be determined. The first set of data covered is the predicted rainfall. Here, the maximum forecast error allowed is 3 days, meaning that the system can search three days to either side of a peak to find a match."""

#Get the peak match accuracy for the precipitation data
prcpAcc = matchPredictionPeaks(prcp_in_dates[prcpSplitIndex:], prcp_outs[prcpSplitIndex:,3], predictedTempDates, peakMatch_rainPreds, 3, "peak", ["Date", "Normalised rainfall"], "Peak detection for predicted rainfall")
print("[+] Peak match accuracy", prcpAcc)

"""The same process is repeated for the snow depth, shown below. Here, two changes are made. Peak detection was a reliable indicator fo rainfall, as it is not a cumulative statistic - each day's rain does not add to the next in the figures. However, snow depth is cumulative. Any increase in depth indicates snowfall. Thus, the peak detection mode is set to `ascend`, checking only that the value has increased since the last measurement. This is somewhat more sensitive to noise."""

#Get the peak match accuracy for the snow depth data
snowAcc = matchPredictionPeaks(snow_in_dates[snowSplitIndex:], snow_outs[snowSplitIndex:,3], predictedTempDates, peakMatch_snowPreds, 3, "ascend", ["Date", "Normalised snow depth"], "Peak detection for predicted snow depth")
print("[+] Peak match accuracy", snowAcc)

snowAccArray = []
prcpAccArray = []
for i in range(0, 7):
  prcpAccArray.append(matchPredictionPeaks(prcp_in_dates[prcpSplitIndex:], prcp_outs[prcpSplitIndex:,3], predictedTempDates, peakMatch_rainPreds, i, "peak", None, None, disp=False))
  snowAccArray.append(matchPredictionPeaks(snow_in_dates[snowSplitIndex:], snow_outs[snowSplitIndex:,3], predictedTempDates, peakMatch_snowPreds, i, "ascend", None, None, disp=False))

plt.figure(figsize=(15,6))
plt.title("Variation of forecast confidence with interval width")
plt.ylabel("Confidence")
plt.xlabel("Prediction error / days")
plt.plot(snowAccArray, label="Snowfall")
plt.plot(prcpAccArray, label="Rainfall")
plt.legend()

"""Above is a graph of forecast confidence against the allowable prediction error. As might be expected, as the allowable error increases, the probability of there being an overlap between the predicted and actual presence of rain / snow becomes higher. This makes sense, as saying that there might be rain in the weeks either side of a predicted spike is bound to include some form of precipitation, and thus be marked as a correct prediction. Further commentary on this is provided in the report.

#4. Predicting the next day

##4.1 Approach
---
The second compulsory task undertaken was to see whether a model can be trained to predict the next days weather, with lower error than assuming it will be the same as the current day. Most of the data handling functionality had been built out at this point, so a single, relatively simple, function was used for every parameter in this task.

`compareNextDayModels` builds and trains a single input network, and uses it to predict the next days weather. An alternate set of predictions is generated by taking the last element of each training batch (the equivalent of "today's weather"), and used as the prediction for the next day.

The two sets of predictions are then compared to the true values, using the mean absolute error as the loss metric, rather than mean square error. This was done for the sake of comparison, since the climate models are trained with mean absolute error as their loss.
"""

def compareNextDayModels(statID, param, windowsize):
  '''
  For a given parameter, compare the performance of a single input network to
  a system which just predicts that the next day's weather is the same as the 
  one before.

  Inputs:
  
  statID [INT]
              Which station to get data from
  
  param [STRING]
              What value to get from the station, TMAX etc
  
  windowsize [INT]
              How large to make the training windows

  Returns:

  nextDayError, modelError [ARR]
              Arrays containing the differences between the predicted and actual
              values, for each point in time
  
  Also plots the two predictions for comparison.
  '''

  #Get the training data and labels etc.
  p_ins, p_outs, p_in_dates, p_means, p_stds = getSequentialDatapoints(statID, dataKeys=[param,param,param,param], windowSize=windowsize,maxTimeInterval=1, predTime=1, maxPredError=0, normalise=True, targetMonths=range(8, 13))

  #Set the outputs of the next day model to just be the previous input
  sameDayPreds = p_ins[:,-1,0]
  pFinalPredictionDate = date(2020,9,30)
  
  #Identify the september onwards values for comparison with the model
  for i in range(0, len(p_in_dates)):
    if p_in_dates[i] >= pFinalPredictionDate:
      pSplitIndex = i
      break

  #Train a model on the same training data, but with the proper next day labels
  pModel, pCosts = trainModel1D(p_ins[:,:,:1], p_outs[:,0], pSplitIndex, 0.2, 100, 350, verb=0, alt=True) #250 is a good value
  p_preds = pModel.predict_on_batch(p_ins[pSplitIndex:,:,:1])[:,0]

  #Calculate the mean absolute errors for the two sets of predictions
  nextDayError = np.subtract(p_outs[pSplitIndex:,0], sameDayPreds[pSplitIndex:])
  modelError = np.subtract(p_outs[pSplitIndex:,0], p_preds)

  #PLot them together
  fig, ax = plt.subplots(1,1, figsize=(15,7))
  ax.plot(p_in_dates[pSplitIndex:], p_outs[pSplitIndex:,0], label="Real")
  ax.plot(p_in_dates[pSplitIndex:], sameDayPreds[pSplitIndex:], label="Same as previous")
  ax.plot(p_in_dates[pSplitIndex:], p_preds, label="Network prediction")
  ax.set_title("Comparison of next day and NN predictions for " + param)
  ax.set_ylabel("Normalised " + param)
  ax.set_xlabel("Date")
  ax.legend()

  #Return the full sets of errors
  return nextDayError, modelError

"""##4.2 Comparing predictive models
---
The first parameter being assessed is TMAX. This is a relatively predictable parameter that was expected to put both predictions on relatively equal footing. The same Canadian station from before was used (ID:201). As can be seen, the models have almost identical errors, but the model's mean error is slightly lower than that of the next day model.
"""

#Get the differences between predicted and actual temperatures
tmaxError = compareNextDayModels(201, "TMAX", 2)
print("Next day model:",np.mean(np.absolute(tmaxError[0])))
print("Actual network:",np.mean(np.absolute(tmaxError[1])))

"""Next, the same process was repeated for the snow depth and as can be seen, the models are almost exactly on par with each other, with very low mean errors over the testing interval. Here, the errors remained similar and resilient to changes in the model, indicating that this is close to a performance ceiling for this particular variable."""

#Get the diff. between snow depth models
snwdError = compareNextDayModels(201, "SNWD", 3)
print("Next day model:",np.mean(np.absolute(snwdError[0])))
print("Actual network:",np.mean(np.absolute(snwdError[1])))

"""The final parameter assessed is the precipitation. This is the least valid comparison of the set, as the neural network far outstrips the next-day model, but this is only because the model predicts a low baseline, which is statistically more likely to be correct, as rain only occurs on specific days."""

#Get the diff. between precipitation models
prcpError = compareNextDayModels(201, "PRCP", 3)
print("Next day model:",np.mean(np.absolute(prcpError[0])))
print("Actual network:",np.mean(np.absolute(prcpError[1])))

"""#5. Climate prediction models

##5.1 Approach
---
This section is concerned with constructing a model that can predict the monthly averages for `TMAX`, `TMIN`, and `PRCP`. Snow depth was excluded from the modelling, as it was rarely present in station datasets, outside of a few high latitude ones. There are three core components to this part of the project:

1. Obtaining monthly averages by binning the daily data
2. Converting the monthly averages into a training-compatible format
3. Training models using this data
4. Applying the models to other stations

One of the key advantages of using monthly averages was that there were relatively few gaps in the dataset. While the approach established with the 30 day system already reduced the impact of this particular issue, it was reassuring to have a better data density. As such, each parameter is predicted using only itself, rather than using temperature to predict everything else.

##5.2 Data preparation
---
There are three key functions here:

`getClimateParams` reads in the station data, and calculates the monthly averages. It also normalises the monthly data for use with training.

`getCLimateTrainingData` then converts this data into network-compatible batches and labels.

`testModel` is the final function, taking trained models and running them on a variety of different data from different stations, allowing for the models to be assessed for their ability to generalise to different locations.
"""

def getClimateParams(whichStat, params, normalise, retLatLong=False):
    '''
    Calculate the monthly averages for a given dataset and parameter

    Inputs:

    whichStat [INT]
                The ID of the station to get data from
    
    params [ARR]
                The parameters to get climate data for

    normalise [BOOL]
                Whether to normalise the data
    
    retLatLong [BOOL]
                Whether to return the coordinates for the station (used
                for the map function)
    
    Outputs:

    allAverages [ARR]
                The full set of monthly averages, for each parameter 
      
    meanStdArray [ARR]
                A list of the means and standard deviations for each parameter

    msg [STATION]
                The station object for the station the data is coming from, returned
                by the ghn.getStation function
    '''
    #Get the filename for this station
    fileName=statNames[whichStat]+'.dly'
    urlName='http://www.hep.ucl.ac.uk/undergrad/0056/other/projects/ghcnd/ghcnd_gsn/'+fileName

    #Download and process the data
    urllib.request.urlretrieve(urlName,fileName)
    statDict=ghn.processFile(fileName)
    msg = ghn.getStation(statNames[whichStat])

    #Get the arrays of measurements
    allAverages = []
    meanStdArray = []

    #Iterate over the parameters
    for p in params:
      monthlyAverages = []

      #Get the data for this parameter
      paramData = np.array(ghn.getVar(statDict,p))

      #Configure the counters for the average
      month_total = 0
      month_count = 0
      currentMonth = paramData[0][0].month 

      #Iterate over the data, if the month changes calculate the average
      for val in paramData:
        if val[0].month == currentMonth:
          month_total += val[1]
          month_count += 1
        else:
          monthlyAverages.append([date(val[0].year, val[0].month, 1), month_total/max(1,month_count)])
          currentMonth = val[0].month 
          month_total = 0
          month_count = 0

      #Get the mean and standard deviation of the datasets and save them
      monthlyAverages = np.array(monthlyAverages)
      mean = np.mean(np.array(monthlyAverages)[:,1])
      std = np.std(np.array(monthlyAverages)[:,1])
      meanStdArray.append([mean, std])

      # If the data needs normalising, get it done
      if normalise:
       monthlyAverages[:,1] = (monthlyAverages[:,1] - mean) / std
      
      #Finally, save the data to the return array
      allAverages.append(np.array(monthlyAverages))
    
    #Return the averages, means / stds and the station object if applicable
    if retLatLong == False:
      return allAverages, meanStdArray
    else:
      return np.array(allAverages), meanStdArray, msg

def getClimateTrainingData(inData, windowsize, predtime):

  '''
  Converts the monthly averages into a training-compatible format

  Inputs:
  
  inData [ARR]
              The averaged data array, formatted like the return value of getClimateParams
  
  windowsize [INT] 
              The number of values to include in each set of training data
  
  predtime [INT]
              How many months into the future to predict

  Returns:

  trainingInputs [ARR]
              The formatted, batched data to use for training
  
  traiingLabels [ARR]
              The labels to supply to the network
  '''

  #Return arrays
  trainingInputs = []
  trainingLabels = []

  #Iterate over each parameter contained within the supplied data
  for parameterData in inData:
    paramTrainingInputs = []
    paramTrainingLabels = []

    #Convert the data to batches, and save it along with the prediction values
    for i in range(0, len(parameterData)-windowsize-predtime):
      inWindow = parameterData[i:i+windowsize,1]
      inWindow = inWindow.reshape(*inWindow.shape, 1)
      predics = np.array([parameterData[i+windowsize+predtime,1]])

      #Save the window and its label
      paramTrainingInputs.append(inWindow)
      paramTrainingLabels.append(predics)
    
    #Save the completed data for this particular parameter into the overall array
    trainingInputs.append(np.array(paramTrainingInputs).astype(np.float32))
    trainingLabels.append(np.array(paramTrainingLabels).astype(np.float32))

  #Return the data
  return np.array(trainingInputs), np.array(trainingLabels)

def testModel(models, statNames, idArr, params, dateRange=[date(2000,1,1), date(2020,1,1)], yRange=[-2,2]):
  '''
  Given a particular climate model, use it to predict the weather from other stations (an arbitrary amount)
  and produce a number of subplots to show the model's performance in each case, and each parameter.

  Inputs:
  
  models [ARR] 
              Model for each parameter (i.e a TMAX model, a PRCP model, etc)
  
  statNames [ARR]
              The names of each station, just to use as a title
  
  idArr [ARR]
              The ids of each station, used to retrieve the data

  params [ARR]
              Which parameters to test. The models array must have one model per
              parameter listed here. Duplicate models are fine.
  
  dateRange [ARR]
              What region to display in the graphs, purely for ease of viewing
  
  yRange [ARR]
              The size of the Y axis
  
  Outputs:

  A p x n grid of plots, where p is the number of parameters and n the 
  number of stations

  '''

  #Arrays to store data in
  datasets = []
  dataBatches = [] 

  #Iterate over the station IDs, and get the raw and formatted data from them
  for id in idArr:
    inData = getClimateParams(id, params, True)
    dataBatches.append(getClimateTrainingData(inData[0], 36, 0))
    datasets.append(inData)

  #Set up the subplot figure with the correct dimensions
  fig, ax = plt.subplots(len(params), len(idArr), figsize=(30,15))

  #Add a title
  fig.suptitle('Actual (blue) vs Predicted (orange) normalised climate based on Shenyang model', fontsize=16)

  #Plot the predictions and real data for each station and parameter
  for i in range(0, len(params)):
    for j in range(0, len(idArr)):
      ax[i][j].plot(datasets[j][0][i][:,0][36:], datasets[j][0][i][:,1][36:])
      ax[i][j].plot(datasets[j][0][i][:,0][36:]+timedelta(days=365), models[i].predict_on_batch(dataBatches[j][0][i]))

      ax[i][j].set_title(params[i] +" for " + statNames[j])
      ax[i][j].set_xlim(dateRange)
      ax[i][j].set_ylim(yRange)

"""##5.3 Training the climate models
---
With the utility functions defined, they can now be used to produce functioning climate models. Instead of the Canadian data from before, the station used for this part of the task was located in Shenyang. This station had extremely consistent data recording, and went back several decades longer than other stations. For this reason, it was used to train a temperature and precipitation model for applications to other stations.

The training data and labels are retrieved as below. In this case, all of the data was used in training, rather than splitting off a test dataset. This was deemed allowable, as the other stations around the world were intended to represent a large test set.
"""

#Get temperature and precipitation data from Shenyang (#300)
data, distInfo = getClimateParams(300, ["TMAX", "PRCP"], True)

#Convert to the correct format
train_in, train_labels = getClimateTrainingData(data, 36, 12)

"""Next, a single-input model is trained using the climate data, and the training performance is displayed below."""

#Train models on each parameter
tmaxModel, tmaxCosts = trainModel1D(train_in[0], train_labels[0], (len(train_in[0])-1), 0.2, 32, 500)
prcpModel, prcpCosts = trainModel1D(train_in[1], train_labels[1], (len(train_in[1])-1), 0.2, 32, 500)

#Plot the costs for reference
plt.title("Traiing and validation losses")
plt.plot(tmaxCosts.history["loss"], label="TMAX loss")
plt.plot(tmaxCosts.history["val_loss"], label="TMAX val. loss")

plt.plot(prcpCosts.history["loss"], label="PRCP loss")
plt.plot(prcpCosts.history["val_loss"], label="PRCP val loss")
plt.legend()

#Test the data on each location for TMAX, TMIN and PRCP
testModel([tmaxModel, tmaxModel, prcpModel], ["Shenyang", "Bahrain", "Canada"], [300, 150, 201], ["TMAX", "TMIN", "PRCP"],yRange=[-5,5], dateRange=[date(2004,1,1), date(2016,1,1)])

"""Above, the models are passed to the `testModel` function for testing against a variety of other stations. Here, the Shenyang model is tested on data from Canada and Bahrain, two very different testing environments. The results are displayed in a grid below. As can be seen, temperature generalises well, but the precipitation results will be the subject of further analysis in the report. For simplicity, the TMIN values are predicted using the TMAX model, which produces acceptable results at the cost of a small deviaton in annual minimum temperatures.

# 6. Conclusion (but not the end!)
---
While the main body of detailed analysis and review is reserved for the report, there are a few immediately apparent observations that are worth commenting on. The first is the clear difficulty in making long range weather predictions, beyond identifying trends. Constructing functional precipitation models proved nearly impossible with the somewhat-patchy data and the approach used here. This mirrors real-world weather modelling however, which is something of a consolation. Less chaotic variables, such as maximum and minimum temperature, could be broadly predicted, but often without much numerical accuracy, and the behaviour of the models was at times inconsistent. 

The temperature climate models generalised well to other stations, and combining variations of the peak detection functions tested here with the climate precipitation models may be an avenue for further enabling generalised predictions, although that is outside of the scope of the code shown here.

The extensions also submitted as part of this project often extend similar techniques as used in this section, and this proved a worthwhile endeavour, particularly in guiding the direction of the Mars data analysis.

---
---

# Extension One: Interactive global climate prediction

## E1. Objectives and technical challenges
---
The objective of this extension is to create an interactive map of the world, providing a quickw way of visualising global trends in temperature, both historically and into the future. This was built to be an extension of the climate modelling functionality from the second compulsory task, and as such has a relatively high temporal resolution, predicting monthly averages rather than seasonal or annual ones. 

There are three steps to this extension:

1. Obtain historical climate data and calculate monthly averages
2. Use a climate model to predict from the last set of measurements to a specified point in time
3. Aggregate this data and visualise it with a heatmap

This was carried at as more of an exercise in data visualisation, and in network prediction stability, than strict accuracy in long range predictions. The reason for this primarily stems from the lack of available data for many of the stations, which often only had 15 years of data, preventing much of the

#E2. Data manipulation

##E2.1 Preprocessing and prediction
---

The data handling for this extension was relatively simple, performing much of the same climate tasks and had been done before, but scaled to 990 stations. The `getWorldTempMap` function iterates over these stations, retrieving their data and formatting it into NN-compatible formats. The final set of batches is used to generate the first prediction, which then becomes the last element of a new batch, with the first element popped off. This preserves the window used for prediction, effectively sliding it forward in time by a month per prediction. This allows for predictions to be made arbitrarily far into the future, although the veracity and stability of this system is discussed in the report.
"""

def getWorldTempMap(model, yearsToPredict, useFullData=False, fullData=None, maxNum=990, showPlot=False):
  '''
  Iterates over all 990 weather stations, retrieves the maximum temperatures, 
  predicts forward to 2040 using a supplied climate model, and then combines
  that with historical data to provide a full dataset.

  Inputs:

  model [NN]
              A fitted climate model with a single input and output.
  
  yearsToPredict [INT]
              How many years from the current data to predict (e.g 40)
  
  useFullData [BOOL]
              Whether to use a supplied dataset instead

  fullData  [ARR]
              Array containing the base climate data for 990 stations,
              so that it doesnt have to be rerieved multiple times.
              Not especially useful.

  Returns:

  coords [ARR]
              Array containing the coordinates of each station
  
  dates [ARR]
              Array containing the dates for each of each stations measurement
  
  temps [ARR]
              The temperatures for each month for each station

  stationNames [ARR]
              The names of eachs station
  
  out_fullData [ARR]
              The raw climate data used which can be used as the fullData input
              if the function is rerun.
  '''

  #Return arrays for the function
  coords = []
  stationNames = []
  dates = []
  temps = []
  out_fullData = []

  #The date to predict out to: 2021 + yearsToPredict -> target year
  targetDate = date(date.today().year + yearsToPredict, date.today().month, 1)

  #Announce the beginning of this arduous computation
  print("[+] Retrieving all the data... from all the stations")
  print("[+] Wish me luck.\n")

  #Iterate over each station and get tmax data only
  #Encapsulated in a try catch, as there are unhandled edge cases where the 
  #GHCND code fails to identify missing data, and this is easier than fixing it

  for id in range(0, maxNum):
    try:

      #Variable for the raw climate data
      climateData = None

      #If supplied, take it from the input, otherwise retrieve it
      if useFullData:
        climateData = fullData[id]
      else:
        climateData = getClimateParams(id, ["TMAX"], True, retLatLong=True)
      
      #Save to the return array
      out_fullData.append(climateData)

      #Get the dates of the next-year predictions
      predictionDates = climateData[0][0][36:,0] + timedelta(365)

      #Pull the latitude, longitude and name of the station
      lat, long = int(climateData[2].lat), int(climateData[2].lon)
      stationNames.append(climateData[2].name)

      #Convert the lat and long into positive values to use in a 
      #360x180 grid
      lat += 90
      long += 180

      #Convert the raw data into batch inputs
      batchInputs, batchLabels = getClimateTrainingData(climateData[0], 36, 0)
      preds = []
      predDates = []
      inputs = list(batchInputs[0][-36:])

      #Calculate how many sequential predictions are required to reach the
      #target year
      monthsRequired = (2+int((targetDate - predictionDates[-1]).days / 365) )*12

      #Calculate forward to the target date, predicting on the models predictions
      for i in range(0, monthsRequired):
        nextYear = model.predict_on_batch(np.array(inputs))
        preds.append(nextYear[0][0])
        inputs.append(nextYear)
        inputs.pop(0)

      #Save the corresponding dates for these predictions
      predDates.append(predictionDates[-1])
      for i in range(1, len(preds)):
        dateInNextMonth = predDates[i-1] + timedelta(32)
        dateInNextMonth = date(dateInNextMonth.year, dateInNextMonth.month, 1)
        predDates.append(dateInNextMonth)

    #Catch keyboard interrupts in case we decide to abort
    except KeyboardInterrupt:
      return

    #Suppress other errors
    except Exception as e:
      continue
    
    if showPlot:
      plt.figure(figsize=(10,5))
      plt.plot(predictionDates, batchLabels[0], label="Historical")
      plt.plot(predDates, preds, label="Prediction")
      plt.legend()
      plt.title(("Historical and predicted temperature for station " + str(id)))
      plt.xlabel("Date")
      plt.ylabel("Normalised temperature")


    #Un-normalise the data so that it can be compared on a heatmap
    finalData = (np.array(list(batchLabels[0]) + list(preds)) * climateData[1][0][1]) + climateData[1][0][0]

    #Combine the date arrays of the normal and NN predicted data
    finalDates = list(predictionDates) + list(predDates)

    #Save the coordinates / dates / temps for the eventual func return
    coords.append([lat, long])
    dates.append(finalDates)
    temps.append(finalData)

    #Progress bar, update very 5 stations
    if(id % 5 == 0 and id > 0):
      print(">5>", end="")
    if(id % 100 == 0 and id > 0):
      print("\n\n[OK] Processed", id)

  #Return the complete datasets
  return coords, dates, temps, stationNames, out_fullData

"""
## E2.2 Data visualisation
---
With the data processed in this way, it can now be passed to `displayMapData`, which translates the supplied station latitude and longitude into a location within a 360x180 grid, representing a map of the Earth in 1x1 degree tiles. This is a relatively simple process, where, the coordinates are used as the indices of elements within the array, allowing them to be set directly. The advantage of this coordinate system is that it allows for a map to be generated directly from the station positions, which represent a rough shape of the Earth's landmasses, rather than overlaying terrain borders or importing additional modules.

The colour scheming is defined with maximum and minimum temperatures of +- 55 degrees celsius, a value that was set empirically to provide the best 

This function returns the data for a specific point in time, as specified by its inputs. This allows for specific dates to be retrieved and displayed in sequence, which is required for interactive widgets. 

There are a few key caveats, however. As stated earlier, some stations came online later than others, or are missing chunks of data. In these cases, if there are measurements made within five years, and in the same season (defined as one month either side of the target month), the closest one is chosen. This aims to strike a balance between maintaining a cohesive map while not showing data that is completely inappropriate in some cases. 
"""

def displayMapData(mapData, year, month):
  '''
  Displays the map data from the above function at a specified time.

  Inputs:

  mapData [ARR]
                Array of temeratures from the stations, as formatted by the 
                getWorldTempMap function
  
  year    [INT]
                The year to display
  
  month   [INT]
                The month to display
  
  Returns:

  A heatmap of the combined data, geographically arranged using the station
  coordinates.
  '''

  #Get the date to display using the inputs
  mapDate = date(year,month,1)

  #Fill the map array with -100 degree temperatures to zero the heatmap
  worldGrid = np.full((180,360),-100.)

  #Extract the relevant data from the mapData variable
  coords = mapData[0]
  dates = mapData[1]
  temps = mapData[2]
  names = mapData[3]

  #Set variables for getting the max / min temperatures and locations
  #Setting them like this ensures they get set by the stations no matter what
  maxTemp = -200
  maxCoords = []
  minTemp = 200
  minCoords = []
  maxName = ""
  minName = ""

  validStations = 0

  #Iterate over the dates of each stations measurements to find the closest
  #reading to the one reqeusted by the inputs
  for j in range(0, len(dates)):

    #Select this stations date array
    d = dates[j]

    #Variables for storing the closest values
    valIndex = -1

    #If the month is exactly in the dataset
    if mapDate in d:
      valIndex = d.index(mapDate)

    #If this data is missing (in the case of historical measurements)
    #Search for the closest measurement: must be in the same season, and within five years
    else:
      #Return variables to use for comparison
      yearDiff = 1000
      monthDiff = 1000
      closestApproach = -1

      #Iterate over the dates and find the year and month difference
      for i in range(0, len(d)):
        yDiff = d[i].year - year
        mDiff = d[i].month - month

        #If we're now leaving the acceptable region, quit
        if yDiff > 5:
          valIndex = closestApproach
          break

        #Otherwise, calculate the absolute distance from the desired date
        else:
          yDiff = abs(yDiff)
          mDiff = abs(mDiff)

        #See if this date is closer than the last best estimate
          if yDiff < 5 and mDiff < 2:
            if yDiff < yearDiff or (yDiff == yearDiff and mDiff < monthDiff):
              closestApproach = i
              yearDiff = yDiff
              monthDiff = mDiff

        


    #Get the coordinates of this station and use it to set the map array elems
    lat, long = coords[j]

    #If there was valid data, save the temperature
    if valIndex != -1:
      worldGrid[lat][long] = temps[j][valIndex]
      validStations += 1

    #Otherwise, hide it from the map
    else:
      worldGrid[lat][long] = -100


    #If above the max or below the min temperature, update them to display
    if valIndex != -1:
      if temps[j][valIndex] > maxTemp:
        maxTemp = temps[j][valIndex]
        maxName = names[j]
        maxCoords = lat,long
      if temps[j][valIndex] < minTemp:
        minTemp = temps[j][valIndex]
        minCoords = lat, long
        minName = names[j]

  #Output the max and min global temperatures on this specific date
  tempString = "Max temp: " + str(maxTemp.round(2)) + " Celsius @ " + str(maxName) + " " + str(maxCoords)
  tempString += "\n\nMin temp: " + str(minTemp.round(2)) + " Celsius @ " + str(minName) + " " + str(minCoords)
  tempString += "\n\nTotal of " + str(validStations) + "/" + str(len(dates)) + " stations online"
  #Plot the map and colourise
  fig, ax = plt.subplots(1,1, figsize=(20,35))
  cax = fig.add_axes([0.95, 0.4, 0.05, 0.2])
  im = ax.imshow(worldGrid, origin="lower", cmap="magma", vmin=-70, vmax=70)
  fig.colorbar(im, cax=cax)

  ax.text(0.01, 0.03, tempString,
        verticalalignment='bottom', horizontalalignment='left',
        transform=ax.transAxes,
        color='white', fontsize=12)
  
  ax.set_title(mapDate, fontsize=15)

"""##E2.3 Training the predictive model
---
The model used here is one based on the Shenyang data, as it seemed to be particular stable, making it a viable candidate for long term predictions. Unfortunately, there was a tendency for recursive predictions to suddenly converge to a single value. This was adjusted for by increasing the input window size, applying additional stabilisation to the predictions, and this appeared to resolve many of the issues. Relatively small numbers of training iterations were used, to try and avoid potential overfitting issues, although the success of this is debateable.
"""

data, distInfo = getClimateParams(912, ["TMAX"], True)
train_in, train_labels = getClimateTrainingData(data, 36, 12)
globalModel, globalCosts = trainModel1D(train_in[0], train_labels[0], (len(train_in[0])-1), 0.3, 32, 100)

"""To verify that the model is stable, the map builder is first run with two overrides, only looking at first station, and outputting the results. The full process is still carried out on the station, but the loop doesn't continue. As can be seen below, the current model is very stable when predicting out until 2040. However, it may be too stable to be sensitive to temperature trends, which will be examined later."""

#Retrieve the map data - take a seriously long time to predict everything
testMapData = getWorldTempMap(globalModel, 20, maxNum=1, showPlot=True)

"""With the model's stability verified, the final step is to download the full dataset, and predict the monthly values up to 2040. This is a lengthy process, taking upwards of 25 minutes.

__As stated before, there are screenshots at the bottom if running it takes too long.__
"""

#Last warning: This will take a while
mapData = getWorldTempMap(globalModel, 20)

"""#E3. The Map

## E3.1 Interacting with the data
---
With everything in place, it can be passed to the interactive map function, and displayed out. The month and year were made independantly controllable to allow for better qualitative comparisons to be made, either comparing the same month across multiple years, or different months in the same year. Also displayed are the maximum and minimum station temperatures for any given point in time. 
The last feature of note is the colourbar on the right hand side, acting as a key for the display. The background has specifically had an extremely low temperature set, hence the black appearance.
"""

#Launch the interactable map and let the user play around with the date and month
yw = widgets.IntSlider(value=2030, min=1950, max=2040)
mw = widgets.IntSlider(value=1, min=1, max=12)
interact(displayMapData, mapData=fixed(mapData), year=yw, month=mw)

"""## E3.2 Preliminary Observations and Conclusion
---
Despite relatively low expectations, the map provided a surprisingly interesting visualisation of global temperature distribution. Moreover, it doubled as a timelapse of the coverage of the GHCND network as a whole, beginning with North America, Europe and Australia in 1950, and expanding into Asia, South America and Africa during the 1960s and 1970s. While not particularly helpful in climate modelling, it is an interesting byproduct.

Scrolling forward to 2030 and 2040 indicates a significant increase in temperature at high latitudes, with winter temperatures in northern Siberia reaching 20 degrees celsius, compared to  -10 in earlier years. This is rather dramatic, and the magnitude of the change is likely the product of the recursive predictions, but aligns with the current expectations that average temperatures will rise, with a severe impact on the Northern Hemisphere, particularly the Arctic Circle. Interestingly, the global maximum and minimum temperatures do not increase or vary as severely as the temperatures in the northern latitudes, suggesting that the temperature increase is not uniform across the Earth's surface. Further analysis is carried out in the report, particularly regarding the predicted trends. 

This proved to be particularly interesting, especially in efficiently trying to find and eliminate errors and missing data, and the functionality of the final result was unexpected. The validity of the predictions, as well as further analysis and review

---
---

![1950.png](data:image/png;base64,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poiIiIiIiIiIiKRaysAUEREREREREZGXknYhTxuUgSkiIiIiIiIiIiKpljIwRURERERERETkJWRiKgMzTVAGpoiIiIiIiIiIiKRaysAUEREREREREZGXjgnEG8rATAuUgSkiIiIiIiIiIiKpljIwRURERERERETkpaRdyNMGZWCKiIiIiIiIiIhIqqUMTBEREREREREReQmZysBMI5SBKSIiIiIiIiIiIqmWMjBFREREREREROSlY5KQgympnzIwRUREREREREREJNVSBqaIiIiIiIiIiLyETOKJe9GDkBRQBqaIiIiIiIiIiIikWsrAFBERERERERGRl5LWwEwblIEpIiIiIiIiIiIiqZYyMEVERERERERE5KVjYhJvKAMzLVAGpoiIiIiIiIiIiKRaysAUEREREREREZGXknYhTxuUgSkiIiIiIiIiIiKpljIwRURERERERETkJWRqF/I0QhmYIiIiIiIiIiIikmopA1NERERERERERF46JhBvag3MtEAZmCIiIiIiIiIiIpJqKQNTREREREREREReQloDM61QBuZ/gI/POW7ejGTu3Nn/733XqlWLyMhw4uJuU6tWrX+lD9OMpWDBgo+sU7VqVU6dOv6v9C/yb8iQIQPHjx8hd+7cL3ooz2Tv3t2UKFHiRQ9DRERERERE/sPSZADTx+ccMTE3yZ49u9X5gwf/xjRjcXNze679ubm5YZqx2NjYPNd2n6fGjd/F07OT5f0ff2wmKCiA69dDOXToAE2aNLaq37v3h1y4cJbr10P5++89VKlSJdm2t27dQnR0FJGR4URGhlsFCrds2YKdXTYuX778yPHVrVuX7du3EhERRlBQANu2/UHjxo2e7maTsHPnTooVK/nc2ntYq1Yt2bx5I4GB/gQE+LFhwzree+/dx16XPn16hg0bypkzJ4mKuo6PzzlmzJie6Ds6a9YM7ty5lSiYNWzYUG7fjiYyMpywsGB27fqTihUrWsqrV6+OacYyadJEq+v+/HM7Xl6eVufu1R0w4H9W5+99v+99vj4+5/jsswEAtG7dCh+fc4nuy8bGhsBAfxo2bAhA8eLFWbHid8LDQ4iICOOPPzZTqVKlRH2sWbPKqh1v7zkMGzb0kXP4uHHf+13OmjWDmJibREaGExISxMaN6ylatKilvpeXJ7GxMURGhnP9eij//LPfMn6ArFmzMnny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No+v+B9VvXp15s2bg6vra091/alTx3F2dub335fTqVOX5zu4x6hZsybLli0hY8aMeHg0TjIQmJbZ2NiwdOli0qVLx+jRYzh06BCZM2emadMmDBjQn4oVqzzTpiry8sqQIQP//LOfWrXqcvVq4g2EnsT06T+zdOkyNm7c+JxGl3J79vxF167dOH48cQa3iIiIiIi8aHEHTNN860WPIrXKYGtv5rAr96KHkWr5h/+Rar4/CmCmAs8awJR/l2EYdOrkRZcunSlevBi3b99m69ZtjBnztYI2IiIiIiIikoopgPkoGWztTCe7si96GKlWQPj2VPP9sX18FZGXm2mazJo1m1mzZr/ooYiIiIiIiIiIvHQUwEwFtm/fruxLEREREREREZH/RyZgmqlrrUdJmgKYIiIiIiIiIiLyEjJT3WY1krQ0vwu5iIiIiIiIiIiI/HcpA1NERERERERERF4+Jphm3IsehaSAMjBFREREREREREQk1VIGpoiIiIiIiIiIvIRMTK2BmSYoA1NERERERERERERSLWVgioiIiIiIiIjIS8cETFMZmGmBMjBFREREREREREQk1VIGpoiIiIiIiIiIvIRMTLQLeVrw1BmYhmG4Goax1TCME4ZhHDcMo+/d846GYWwyDOPs3b8dnt9wRURERERERERE5GXyLBmYscCnpmkeNAzDDjhgGMYmoBOwxTTNrw3D+Bz4HPjs2YcqIiIiIiIiIiLy/GgNzLThqTMwTdMMME3z4N3XkcBJIA/QFJhzt9oc4N1nHaSIiIiIiIiIiIi8nJ7LGpiGYbwGlAH2ArlM0wy4W3QVyJXMNd2B7s+jfxERERERERERkSelDMy04Zl3ITcMIwuwDPjYNM2IB8tM0zRJ2JU+EdM0p5mm+ZZpmm896xhERERERERERETkv+mZMjANw0hPQvByvmmav909HWgYhrNpmgGGYTgDQc86SBERERERERERkefJxCQeZWCmBc+yC7kBzABOmqb5/QNFKwGvu6+9gBVPPzwRERERERERERFJawzD+MgwjFOGYRw3DOObB84PNAzjnGEYpw3DqJeStp7lEfIqQEegpmEYh+4eHsDXQB3DMM4Cte++fyGmTJnE4MFfvKju/zXDhg3l9u1oIiPDyZw584seDlu2bCI6Ooo//9z+r7Q/bNhQvL3nPLbe2rWr8fTs+K+MQVKXBQvm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)

![2000.png](data:image/png;base64,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vmPFipUMGHBPhcf++c8PkJExmZycLRw5cuSYfg6WN954k/r165OVNcff5x988KEKmCIiIiIiIiJB4JzrGu4YpHLsZJfrhiwIMwcnzoSTyuvQoQNTp07hyiuvCncoIiIiIiIiIhIRSv7pnLsi3FGI/Fg15h6YAiNHpoU7BBERERERERERkSqlGZgiIiIiIiIiIjWSZmBKzaAZmCIiIiIiIiIiIhKxVMAUERERERERERGRiKUCpoiIiIiIiIiIiEQsFTBFREREREREREQkYqmAKSIiIiIiIiIiIhFLBUwRERERERERERGJWCpgioiIiIiIiIiISMRSAVNEREREREREREQilgqYIiIiIiIiIiIiErFUwBQREREREREREZGIpQKmiIiIiIiIiIiIRKygFTDNrKuZbTKzrWb2SLDaERERERERERERkZorKAVMM6sNPAN0A9oCvcysbTDaEhERERERERERkZqrTpA+tyOw1TmXA2BmWcAtwIYgtSciIiISEgPiHvMvT8sfFcZIRERERER+GoJ1CXkzYEe59Txvm5+ZDTCzNWa2JkgxiIiIiIiIiIiISDUXrBmYp+ScmwZMAzAzF644REREREREREREJHIFq4C5E0gotx7vbQukAEpygVjfskjQKdckVJRrEirKtRCZlp8a7hDCTbkmoaJck1BRrkmohCPXEkPcnkhQmHNVP/nRzOoAm4Eb8BUuVwO9nXPrT/G+Nc65K6o8IJHjKNckVJRrEirKNQkV5ZqEinJNQkW5JqGiXBM5c0GZgemc+97MBgGLgNrAjFMVL0VERERERERERESOF7R7YDrnFgILg/X5IiIiIiIiIiIiUvMF6ynkZ2pauAOQnwzlmoSKck1CRbkmoaJck1BRrkmoKNckVJRrImcoKPfAFBEREREREREREakKkTYDU0RERERERERERMQvIgqYZtbVzDaZ2VYzeyTc8UjNYmZfmdkXZrbOzNZ42xqb2QdmtsX72SjccUr1Y2YzzGyPmX1ZbluFuWU+U7xx7nMz+3n4IpfqJkCupZrZTm9sW2dm3cvte9TLtU1m1iU8UUt1ZGYJZpZtZhvMbL2ZPeBt19gmVeokuaaxTaqUmZ1tZp+Y2WderqV52y80s1VeTs01s7re9nre+lZv/8/CGb9UHyfJtRfNbHu5cS3Z265zqMhpCHsB08xqA88A3YC2QC8zaxveqKQG6uycS3bOXeGtPwIsds61AhZ76yKn60Wg63HbAuVWN6CV9xoAPBuiGKVmeJETcw1gkje2JXsPz8M7h/YE2nnv+Zt3rhWpjO+Bvzrn2gKdgPu9nNLYJlUtUK6BxjapWsXA9c659kAy0NXMOgHj8eXaRcA+oL93fH9gn7d9knecSGUEyjWAh8uNa+u8bTqHipyGsBcwgY7AVudcjnPuKJAF3BLmmKTmuwV4yVt+CfhtGGORaso59w+g8LjNgXLrFmCW8/kYaGhmF4QmUqnuAuRaILcAWc65YufcdmArvnOtyCk553Y55z71lr8F/gU0Q2ObVLGT5FogGtvkjHjj00Fv9Szv5YDrgfne9uPHtbLxbj5wg5lZiMKVauwkuRaIzqEipyESCpjNgB3l1vM4+S8vIqfLAe+b2T/NbIC3ralzbpe3/A3QNDyhSQ0UKLc01kkwDPIuOZpR7lYYyjWpEt5lk5cDq9DYJkF0XK6BxjapYmZW28zWAXuAD4BtwH7n3PfeIeXzyZ9r3v4ioEloI5bq6vhcc86VjWtjvHFtkpnV87ZpXBM5DZFQwBQJtl84536Ob4r+/WZ2bfmdzjnHyf8yJnJGlFsSZM8CLfFdorQLeDq84UhNYmb1gdeAB51zB8rv09gmVamCXNPYJlXOOVfinEsG4vHN3L04zCFJDXV8rpnZJcCj+HKuA9AYGBrGEEWqrUgoYO4EEsqtx3vbRKqEc26n93MP8Dq+X1p2l03P937uCV+EUsMEyi2NdVKlnHO7vV+SS4Hn+eFSSuWa/Chmdha+gtIc59z/eJs1tkmVqyjXNLZJMDnn9gPZwFX4Ltet4+0qn0/+XPP2xwD/F+JQpZorl2tdvVtmOOdcMTATjWsiZyQSCpirgVbeU+Dq4rs594IwxyQ1hJmda2YNypaBm4Av8eXYHd5hdwBvhidCqYEC5dYCIMV72mAnoKjc5Zgip+24eyTdim9sA1+u9fSeonohvhvDfxLq+KR68u7z9gLwL+fcxHK7NLZJlQqUaxrbpKqZ2Xlm1tBbPgf4Nb57rmYDt3mHHT+ulY13twEfeTPPRU4qQK5tLPcHQMN3r9Xy45rOoSKVVOfUhwSXc+57MxsELAJqAzOcc+vDHJbUHE2B1737btcBXnHOvWdmq4F5ZtYfyAX+EMYYpZoys0zgV0CsmeUBI4FxVJxbC4Hu+B46cAjoF/KApdoKkGu/MrNkfJfyfgUMBHDOrTezecAGfE/5vd85VxKOuKVauga4HfjCu4cXwDA0tknVC5RrvTS2SRW7AHjJe2p9LWCec+5tM9sAZJnZaGAtvoI63s/ZZrYV3wP0eoYjaKmWAuXaR2Z2HmDAOuAe73idQ0VOg+mPSSIiIiIiIiIiIhKpIuESchEREREREREREZEKqYApIiIiIiIiIiIiEUsFTBEREREREREREYlYKmCKiIiIiIiIiIhIxFIBU0RERERERERERCKWCpgiIiIiIiIiIiISsVTAFBERERERERERkYilAqaIiIiIiIiIiIhErP8Hfy3L2sWKXMgAAAAASUVORK5CYII=)

![2040.png](data:image/png;base64,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311ev//+h86cOaMrV65o5szZqlo1aeD04sWLGjRosI4ePSpjjH799VcFBwerdu3/s92/cuUqNWrUMMMB3Zys8cbPbFtKix54z7YBAAAAwH/LKJH/0vzPleTYAcwNGzbKy8tLlStXlpubm9q1a6upU6fZtblw4YICArrK27uwmjV7Rj17dreVT8+aNVt//bVeo0Z9rUKFCmncuB/04ovdde7cuVTPeuyxBpIkb+/C8vT01oYNG/TMMy304Yfvq2XLNipatITWrFmr6dPtn9+48VOqXbuuHnzwEb377tv64Yex6tQpQGXLlle1alXtMkhLlCihIkWKqHTpcgoMfEE//DDWlkHXvn07bd++Nc33ws3NTd9+O1K9e/eRMcbu2ubNm7V37z61aNFcbm5uevbZZ3TlyhXt2LHjhvu63hNPNNK8efPTbFegQAH98ccSBQVNV7FiJdWuXUeNHv2tqlSpkqrtW2+9qZCQEBUtWkLFi5fShx/2zfD51/Pz81Pv3r30wAMPysvLR40bN9WRI0cctn3//XfVr98AnThxQm3atNbhwwd05MghffjhB/rhh7H67bfflJiYqKpVq6b5vMDAAE2fPlMzZsxU5cqV9X//9392140x6tdvgAYM6Cd39xtbL2vDho0KCOist99+S7Vr13aYxemIZVlq0aK5ihQpooMHD9nOBwR01ubNWzRv3s/au3evOnbskOreYcM+UatWLVNlbl7VsuVziomJ0ezZc/T770sdDtqOHj1Gfn6VbAPO16tfv77KlCmjGTNmatas2alK1FOqVKmSEhMTdeLEiYxetqSkr398fLwOHDhgO7d9+w7bQKIkFStWTKdOndDhwwf05ZdfZFvW9rhxE/TIIw+rZMmSuuOOO9SxY3stXrzEYdtixYrJz8/PbhD25MmTiouL07333pst8QAAAAAAcDvJsQOY0tUszM568skntXfvvlQDHatWrdKuXbtkjNHOnTs1ffoMu7nrXnnlVTVs2EArVy7XokW/6Ndff830s3v06K5PPhmuffv2KSEhQR9//Ilq1appl4U5YsTnio6O1p49e7Rr1y4tXfqHgoODFRUVpcWLf9f999svTNKvX3/FxsZq9erV+vXX32xzFU6fPkM1a9oPjqXUp8+r2rjxb23dmnqQMzExUZMnT1FQ0FRduXJRQUFT1b17L128ePGG+7pe4cKFHJbTXtW8eTMdOXJUEydOUkJCgrZt26a5c+c5zMKMi4tTyZIl5evrq/j4eK1duzbD518vISFB+fLl03333Sd3d3cdPXrUlsF4vccf99e8eT/Lx8dHo0d/q9atn5efXxX5+VWyZcZu27ZdlSs7HlAqW7asGjR4XEFB03XmzBktX77CYVn1okW/6OzZc3rxxW439FqmTQvSq6++psaNn9KqVSt05kxoqnknUypVqpTCw8/p0qUY/fzzXL355tu2eSOlpKzHoKDpkqSgoBkOYz19+rTGjv1BgwcPdPiMwMAAzZw5S4mJiQoKmq527Z5PNTB76dIlDRv2iYYOdbw4U2BgZy1evEQREREKCpqhJk0apzmdgbe3t6Kjo9N8zdcrWLCgoqKi7M5FRkbasqz37dunWrVqq2TJMmrY8EnVrv1/+vLLzzPdf3oOHDig48eP2+aCrVKlsgYPHpqqnbu7u6ZNm6JJkyZr//79dteio6Pl7e2dLfEAAAAAADJmlJSDyeZ4cyU5fABzqjp0aKcuXQIczmVXt25drVixTGfOhCoiIkw9enRXkSLXFv6JjIzU7NlzVb16dX3xxVc39Gxf33IaOfIrhYefU3j4OZ0/f1aWZal06dK2NqdPn7btX7p0+brjS3YLxYSHh9sNKh49ekylSpXMMI6SJUuqT5/e+ugjx6W/jRo10ogRn+rxxxvJw+MO+fs31E8/fa+aNWvecF/XCws7r5Il047R19dX9erVtb1H4eHn1LFjB5UoUTxV288++1wHDx7S0qWLdejQv3rvvXczFUNKhw4d0uuvv6mBA/vrzJlQTZ8+Lc34LMtSbGys7rnnHh0+HKytW7cqNjZWM2fOtrUpW7aMTpw46fD+zp07ae/evdq+fbukpAHHDh3aO8y07Nu3vz766APlz5//hl5PUNB0PflkY3l7F1aPHr00ZMggPfXUUw7bnjx5Uj4+ReTl5aNRo75Vw4YNbNcefvhh3X333ZoxY6at3+rVqzv8DAwfPkKNGz+lGjVq2J0vU6aMGjR4XNOmJQ2CLliwUPnz51ezZk1T9fHTT+NUvHixVIvS5M+fX23atNa0aUmLEW3YsEHHjh1Lc7qE8PBw2+BjZsTExMjLy8vunJeXl20Q9PTp09q7d6+MMTpy5Ijeffd9tWrVMtP9p+e7775Rvnz5VKhQUd15p5fmzZuvxYvt/yBiWZamTJmk2NhY9e7dJ1Ufnp6eioiIyJZ4cpLIuDy2DQAAAAAAR3L0AOaxY8cUHHxETZs+rXnzfk51PShoihYuXKSyZcvL27uwxo793javoiTVrFlTL7zQRUFB0zVq1NdpPsdRKfPx4yHq3r2nfHyK2LYCBTy1fv36m3otPj4+duWs5cqV1cmTaWc3XlW37gMqWbKk9uzZqdDQEI0c+ZXq1n1AoaEhcnNzU61aNbV69Rpt2bJFxhht3rxZGzf+rSeeSF3im1Ff11u2bLmee+5Zu/c0pePHj2vVqtV275Gnp7d69eqdqm1MTIzefvsdVazop2eeeU5vvvm6w/krL1y4YPc+XT8YOn36DD36qL98fSvIGKPhwz9xGFtiYqLy5s2rgwcPqkKFu3X//ffLw8NDbdu2Vp48edS2bRuVL19emzZtcnh/QEAnVahQQaGhIQoNDdGXX36uokWLqmnTpx28T8t08OAh9erV02FfGYmPj9ecOXO1Y8cOVauWdkm7JMXGxuq9995X9erVbNMlBAZ2lmVZ2rZti0JDQ7Rx41/J51OXb58/f15ffz1KQ4YMsjvfuXMn5cmTR4sWzVdoaIjGwPfEAAAgAElEQVQOHz6g/PnzO+wjLi5OgwYN0ZAhA+0+G8899z/dddddGj36W9v7Vrp0aYel6JJ08OBBWZZlW807I//++6/c3d11zz332M7VrFnD4XyZUtL3dWZL8zNSq1ZNTZw4SeHh4YqNjdU333yrevXqqnDha38wGTfuRxUvXlytWrVRfLz9CuqlSpWSh4dHqqxMAAAAAMCtZGRMAlsamyvJ0QOYktSt20tq2PBJhyXRnp6eOn/+vK5cuaIHHnjALtMrX758mjp1kj78sK+6du2m0qVLqWfPHg6fcfbsWSUkJKhChQq2c2PHfq8PPnjPtsKxl5eXWrdulaXXMmjQQOXNm1f169dX8+bNNHv2nAzvWbx4icqXr6hatWqrVq3a6t9/oP75Z5tq1aqtxMREbdq0WY8+Wt+WbVerVi09+mh97dix84b7ut6XX34lLy8vTZo0wVY6X6pUKX3xxeeqXr26fvnlV/n5VVKnTh3l7u4ud3d31alTR5UrV07VV7NmzWwLC0VGRiohIcHhM7dt266mTZvIx8dHxYsX1+uvv2a75ufnpwYNGsjDw0OXL1/WpUuXHPYhSX/9tV4tWjRXeHi4evXqrblzZ2nHjn8UEnJCjzzysJ566kk9++xzDhdsefDBB1WxYkXVrfuQ7b2qVq2mpk0LcrjCtyR99FE/vfvu2w6vORIYGKCmTZuqYMGCsixLTZo0UdWqVbVx498Z3hsXF6cvvvhK/fv3Vb58+dS2bRu9/HIPW6y1atXWq6++pg4d2ilPntRZb19++ZUefvghValy7esUGNhZAwcOtuujVas2atr0aRUqVChVH1OmTFX+/PnVpElju9c0btx4Va9ey9bHI488ppo1a6patWoOX8eyZcvl7/+Y3fl8+fLZFrtJuX/x4kXNm/ezBg8eqAIFCujhhx/Ws88+Y1vF/PHHH7d9TsuUKaNPP/1YCxYstPU7YcK4dBdu8vDwUL58+VLtS9KmTZsVENBZXl5ecnd3V69ePXXixAmFhYVJksaM+U5VqlRRixbP6vLly6n69vd/TCtW/KnY2Ng0nw8AAAAAQG6V4wcwDx8+rC1btji81qtXbw0ePFBRUeHq37+vZs26Vh78yScf6/jxEI0d+33yStGBGjp0sF321lVX5/Vbt261wsPPqV69epo/f4GGD/9MM2ZMU2Tkee3atV1PP93kpl/HqVOnFB4erpMnj2vatMnq0aOXLRurQ4f22rVru8P7YmNjdfr0adsWGRmpuLg4W7n66tWrNXDgYM2ZM1NRUeGaO3eWPv74U/3xxx+p+s6or+uFh4fr4YcfVVxcnDZu/EtRUeFavnypIiMjdfDgQcXExOipp55Wu3bP6+TJ4zp16oSGD//EbuDnqkqV7tGyZb8rJiZS69ev1ejRY7Vy5cpU7aZMmart23foyJGkcvOZM2fZruXLl0+ffvqxzp07rVOnTqhYsWL64IOPHMb+6acj9Mknw1S8eHHNnj1HFSpUUuXKVdWvX39VrOinl17qrjNnzji8NzCwsxYsWKhdu3bZvV8jR36j5s2bycfHJ9U9f/31l/7+23E2pyNRUVH68MP3dexYsCIiwjRixCfq2fMVrVu3LlP3jx+fNKjcpk1rXbp0SZMnT7GLdfz4CXJ3d1eTJqk/s9HR0Rox4nNb9mC9evXk6+ur774bbdfHokW/6ODBg3aLUV2VmJio/v0H2vooVaqUGjVqqK+/HmXXx9atW7Vkye9pLubz/fc/2q0i7uvrq8uXL2jPnqQB+MuXL2j//msZlr169dYdd9yRPIXAVPXs+Yr27Em6fv/9tfTXX2t04UKU/vprjXbu3Kk+fV633Vu2bFmtW/dXmu/p/v17dPnyBZUpU0ZLly7W5csX5OvrK0l6++13dfnyZR04sE9nz55S06ZP67nnkuZ6LVeunHr06K5atWrq1KkTio6OUHR0hN0fVDp27KCxY79P89nOtKTeO7btVui07WPbBgAAAAD/NWev9O3K/7kS60ZXer4lQViWkXLv/Gf+/v6aOnWSypYt7+xQcpX27dtp8OCB6t9/oBYvXqLo6GjVrl1bAwf219Sp02yL3sC51q5drd69+9gtSpTd8ubNq+3bt6pGjftTlXffatWrV9f334/Rww/X/0+fm1kpBy6bbPzMiZEAAAAAuHEJW4wxdZwdhavycPcyRT0fcHYYLutkxAqX+fykXnEEyCWmT5+hPXv26r333tGIEZ/qzjvv1J49ezV27PcMXrqQ+vUfy7hRFsXFxem++6rf8uc4snPnTpcdvAQAAACA25uRkWvN9QjHGMBErrZ9+3Z16NAp44YAAAAAAABwCkrIAQAAAABOEXT/h7b9Dv8wJ/Z/YXyNa+sEvLBjmBMjwX+DEvL05HX3NEUK3u/sMFzWqcg1LvP5IQMTAAAAAAAAuZBxucVq4FiOX4UcAAAAAAAAwO2LEnIAyCVYURwAkFXfV+9r2+++c6gTIwEAZA4l5OnJm6eg8SnonAVdc4KzURtc5vNDBiYAAAAAAAAAl8UcmAAAAAAAAMiFjAxzYOYIlJADAAAAuO39VONa+fuLOyh/B5BbUEKenrx57jTeBas5OwyXdS7qb5f5/JCBCQAAAAAAgFzHSDKGDMycgDkwAQAAAAAAALgsMjABAACAFILu/9C23+Gfj50YCbKKsnEAQPqMjBKcHQQy4aYzMC3LKmtZ1p+WZe2xLGu3ZVmvJZ8vZFnWH5ZlHUj+v0/2hQsAAAAAAAAgN8lKBma8pLeMMVsty/KUtMWyrD8kdZG03BjzqWVZ70t6X9J7WQ8VAAAAAAAAyD7MgZkzZNsq5JZlLZD0bfL2uDEm1LKskpJWGmPuzeBeViEHAABZ9l21frb9V3YNcWIkt96kmh/Z9gO3D3NiJAAAwHWxCnl63PMUMF4F/JwdhssKj9nuMp+fbJkD07Ks8pLul7RRUnFjTGjypVOSiqdxz8uSXs6O5wMAAAAAAAA3igzMnCHLq5BbllVQ0lxJrxtjolJeM0npnQ5TPI0xPxhj6rjKSC4AAAAAAAAA15OlEnLLsvJK+kXS78aYL5PP7Rcl5AAAIIcbVfVaOXqf3bd3OToAALhdUUKenjx57jAF76jo7DBcVtSF3S7z+cnKKuSWpHGS9l4dvEy2UFJg8n6gpAU3Hx4AAAAAAACAnMayrFcty9pnWdZuy7JGpDj/gWVZBy3L2m9ZVuPM9JWVEvJHJHWW1NCyrG3JW1NJn0p60rKsA5KeSD52ijFjvlPfvh9l3BAuy5h4VayY/l9D6tevr337dv9HEQGpFSlSRHv37lL+/PmdHUq65syZpSZNmjg7DAAAAABwGcYksqWxZYVlWQ0kPSuppjGmqqTPk8/fJ6mdpKqSmkgabVlWhmXZNz2AaYxZa4yxjDE1jDG1krffjDFhxphGxphKxpgnjDHnb/YZaQkOPqgrVy6qcOHCdue3bt0kY+Ll6+srSerZ8xUNHXpzq3L++edydev2QpZj/a899thjMiZeQ4YMtjs/ZMhghYQcVUREmP78c7nuu+8+h/cXLVpUQUFTdeLEMUVEhGnt2tWqW7euXZvevV/R4cMHFBl5Xps2bdAjjzySbkxPPfWUVq36U1FR4TpzJlQrV65QixbNs/ZCU1i7dq0qV66abf1dr23bNlq2bKlOnz6p0NAQ/f77Yj333P/SvcfX11fGxCs6OkLR0RE6deqEFi1aoCeeeMKunaMB2gED+mvKlEmSJH9/fxkTr3nz5ti1qVGjhoyJ159/Lrc7//bbb+nff/fq4sVoHT16WB9/PEweHh626xMmjJMx8XrggQds5ypWrChj4iVJu3Ztt8UcH39Fly7F2I4/+OD9VK9zwID+io29pKiocEVFhWv//j365puRKlGihK2Nv7+/Lc6r70uePPY/myZMGGf7zAYGBig+/oqioyMUGXle27ZtUbNmzSQl/VFi0qQJqeKoUaOGLl++IB8fH7v3L633+Opz1qxZleq8lPT9n/K1R0dHaOHC+Q7bStL777+niRMn6/Lly5IkDw8PjRv3oyIjzys0NERvvPF6mvde7/HHH9eKFcsUERGm4OCDqa7XrFlTq1evVEREmI4fP5LqjzQNGzbU3r27dOFClFasWKZy5crZrg0f/pmGDh2U6ViA3K7P7iG2DQAAAMAN6SnpU2PMFUkyxpxJPv+spBnGmCvGmGBJByXVTaMPmywv4uMswcHBat++ne24WrVqKlCggBMjcj53d3eNHPmlNmzYaHe+TZvWeuGFLnr00cdVqFBRrV+/QVOmTHTYR8GCBbVp02bVrl1XhQoV1aRJk/Xrrwt15513SpLq1q2rTz/9WK1bP6+77iqkceMm6Oef58jNzfFHqVWrlpo9e4YmT56iMmV8Vbx4KfXvPzBbBzBvFTc3NwUFTdVLL72ojz/+VBUqVFLZsuU1cOBgvfzyS/rhh7EZ9uHtXVient6qWfP/9Mcfy/Tzz3MUGBhwQ3GcOXNGDz30oAoVKmQ7FxgYoP3799u1GzXqa7388osKCOgqT09vPf10czVq1FCzZs2waxcWFqahQ+0HuK+qVq2mPD295enprTVr1qp37z62408+cZxMPXPmLHl5+ahQoaJ67rnWKlGihLZs+dtuEPNGrV+/QZ6e3vL2LqzRo8dqxoxpuuuuuzRp0hS1bPlcqu/1zp076ZdfflV4ePhNP/N6KV+7p6e3nnnG8aC1h4eHAgM7a+rUabZzAwcOUKVKleTrW0ENGjyhd999W40bZyorXhcuXND48RP0zjvvObweFDRFq1evUaFCReXv31C9evWwfT8VLlxY8+bNVr9+A1SoUFFt3rxFM2dOt927adMmeXl5qXbt2pl9GwAAAADg9mWMjElgS2PLIj9Jj1qWtdGyrFWWZV3NpCot6XiKdiHJ59KVYwcwp0yZpoCATrbjwMAATZ481a5Nyqwuf39/HT9+RG+++YZOnz6pkyePq0uXQDkydOgQPfpofX377ShFR0fom29GSpLuvfdeLV26RGFhZ7Rv3261adPa7lnfffeNfvvtF0VHR2jt2tUqXry4vvrqC50/f1Z79+5SrVq1bO2Dgw/q/fff0+7dO3T+/FmNH/+T8uXLl6X35K233tTSpcu0b98+u/N333231q5dp+DgYCUmJmrq1GlpZmAGBwfrq6++1qlTp5SYmKgff/xJHh4euvfepHWYypf31e7de7R161ZJ0uTJU1S0aFEVK1bMYX9ffvm5hgwZpnHjxisqKkrGGK1evVovv9zD1qZr1y7as2enzp8/qyVLfrPLGEvp6aef1u7dOxQVFa6QkKN66603JV372l51fcZdys9B4cKFtWjRAoWHn1NY2BmtXr1SSdO5pvbRRx/qypUrevLJxlqxYoUuXLig+Ph4rV+/Xk2bNpeXl5c6d+7k8N7rnT59WqNGfaOBAwdr+PBP0nymI7GxsZo/f4HatXteUtLA6vPPt9G0adcGpu655x716tVTHTsGaMOGDUpISNCePXvUqlUbNWnSWA0aNLC1nTRpimrUqK7HHnss0zFkRnx8vPbs2aPnn2+vs2fP2r4+WWGM0ZQpU1WwYEFVqlRJGzZs0IkTJ9SqVUtbGzc3N3Xo0E6TJ0/J8vNuRr169RQREaETJ07YzgUGdtaQIcMUERGhffv26ccfx6lLl8wNXG/atElTp07T4cPBDq+XL19e06YFKTExUYcPH9batetUtWpSBnLLls9p9+49mjNnrq5cuaKBAwepZs0atu9fSVq5cpWaNWuahVcMAAAAAMgliliWtTnF9nLKi5ZlLbMsa5eD7VlJ7pIKSXpQ0juSZlk3MhhynRw7gLlhw0Z5eXmpcuXKcnNzU7t2be0yoBwpUaKE7rrrLpUuXU7dur2s7777Rt7e3qna9e3bzy777NVXX1OBAgX0xx9LFBQ0XcWKlVS7dh01evS3qlKliu2+tm3bqG/f/ipSpLiuXLmi9evXauvWf1SkSHHNmTNPX375ud1zOnZsr8aNm6piRT/5+fnZlYKGh5/LsDQ7pXLlyumFF7po8ODUZW4zZsxUxYoVVKlSJbm7uyswMEBLlvyeqX5r1qwpDw8PHTyYVMq6ePES5cnjprp168rNzU0vvNBV//zzj06dOpXq3nvvvVflypXTnDlz0+z/mWda6MMP31fLlm1UtGgJrVmzVtOnO/46jhv3g7p37yUvLx9Vq1ZTK1b8manXkNJbb72pkJAQFS1aQsWLl9KHH/aVMSZVuwIFCujFF1/QK6+8qrx582rcuB91+vRJ/fnnco0f/5Pq16+vN998W3369L6h58+b97OKFy9uN6CUGZMnT1VAQGdJUuPGjbVr126dPHnSdr1Ro4YKCQnRpk2b7O4LCQnRhg0b9eST10rXL168qI8//lTDht2aksjExEQtWLBIjz5aX5K0atUqNWjQ6Kb6cnNzU9euXRQbG6ujR49Ksn8vJOmJJ55Q3rx59dtvi7Me/E2oXr2a9u//13bs7e2tUqVKafv27bZz27dvV9Wqjv9ocKO+/nqUAgI6y93dXX5+fnrooQe1bFlSiX7VqvfZPffixYs6dOiQ3bP37t2nmjVrZEssAAAAAJDTGSWypbFJOmeMqZNi+8HuvUuaOrKag22BkjIr55kkf0tKlFRE0glJZVN0Uyb5XLpy7ACmdDULs7OefPJJ7d27zy4DypG4uDgNHjxE8fHxWrx4sWJiYjI9kNS8eTMdOXJUEydOUkJCgrZt26a5c+fZZWH+/PN8bd26VVeuXNHPP8/X5cuXNWXKVCUmJmrmzFm6//5adn1+++1ohYSEKDw8XMOGfaL27Z+3XfPxKaJ169Zl+r0YNepr9es3QBcuXEh1LTQ0VGvXrtO//+7VpUsxatOmld54460M+/T09NSUKRM1aNAQRUVFSZKio6M1d+7PWrt2la5cuagBA/rp5Zd7Orz/6hyloaGhaT6jR4/u+uST4dq3b58SEhL08cefqFatmg6zMOPi4nTffVXk6empiIgI/fPPPxm+Bkd9lCxZUr6+voqPj9fatWsdtnvooYf0558rdfHiRXXr9oLKlCmje+65Vy+88KIaN35Kbm5uOnnyZKp5WDNyddAxZTl4Zqxfv16FCvnIz89PAQGdUmUbFilSRKGhqQeRpaT3v0gR+zi///4HlStX9pYt6HLy5EkVKuRz0/c/+GA9hYef0+XLF/T55yPUqVOAzp49K0maMmWq/P0fU+nSSRnmAQGdFBQ0XfHx8dkS+1WjRn2t8PBztm3wYMdzR3p7eys6Otp2XLBgQUlSZGSk7VxkZJQ8PT2zJa5ffvlVrVu31KVLMdq/f4/GjZugzZs3254dGRll1/76Z0dHRzv8ww0AAAAAANlovqQGkmRZlp8kD0nnJC2U1M6yrHyWZd0tqZKkvzPqLIcPYE5Vhw7t1KVLQKbKR8PCwpSQcK2G/+LFi7bBhoz4+vqqXr26dgMaHTt2UIkSxW1tTp8+Y9u/dOlSquPrn3X8eIht/+jRoypVqlSmYkm50Er9+vXVvHlzeXp6atas2Q7b9+/fTw888IDKlPFV/vx3atCgIVqx4g/dcccdaT4jf/78WrRogTZs2KhPPx1uO9+t2wvq2jVQVavWkIfHHerUKVC//LJAJUuWTNVHWFiYJDm8dpWvbzmNHPmV7T09f/6sLMuyDU6l1KpVWzVt+rSOHj2slStX6MEHH0yz37R89tnnOnjwkJYuXaxDh/7Ve++967BdsWJFdeJE0mBj9erVNH/+AkVHRys4OFhr1yYNLBcsWNDhgHF6rr6u8+eT1raKj49X3rx57drkzZtXcXFxqe6dMmWaevfupQYNHtfPP9svKHPu3DmVLOl4zsmSJUvq3Lkwu3OxsbEaMmSYhgwZeEPxZ1bp0qV1/nzq+SivDjJm9Jo3bNgoH58i8vEpooULr2VzStLx48e1evUaderUUXfeeaf+979nU00fkR369HndFoOPTxH17z/AYbvw8HC7AcKYmBhJkpeXl+2cl5en3SDnzfLx8dGSJb9q8OChyp//TpUp46vGjZ9Sz549bM/28rIfKL3+2Vf/AAAAAAAAME5f6duVtywaL6mCZVm7JM2QFJicjblb0ixJeyQtkfSKycSEmzl6APPYsWMKDj6ipk2f1rx5P2dr39eXFR8/flyrVq22G9Dw9PRWr143VkKcUtmyZWz75cqVsysJTk/KhVbWrl2rRo0aqE6d2goNDVFoaIief76tXn+9j+bPnydJqlWrpmbOnKUTJ04oISFBkyZNlo+PT5rzYHp4eGj+/HkKCQlR9+722ZW1atXUL7/8pgMHDsgYo99//12hoaF6+OGHUvWzf/9+HTt2zG6+wusdP570jJTva4ECnlq/fn2qtps3b9b//tdSxYqV1Pz5CzRr1nQHPSYtgpJykZeUi8nExMTo7bffUcWKfnrmmef05puvq2HDhqn6OHcuzDYguHPnLv3vf8+qYMGCKl++vOrXf0Q+Pt4aPfpbjR8/Mc3X5shzz/1Pp0+fti3Ac+zYMZUvX96uzd13l9fRo8dS3TtlylT16tVTv/22WJcuXbK7tmLFnypbtqzd6uKSVKZMGT34YD0tX74iVX8TJkyUt7e3WrZ87oZeQ0Ysy1KLFs20Zk3q7NbQ0FDFxsY6eM1320rEU7pw4YJ69nxFnTt3sptDdtKkyercuaNatWqp4OBg25yszrBjx075+VWyHUdEROjkyZOqWbOm7VzNmjW1e/eeLD+rQoUKSkhI0JQpU5WQkKATJ05oxoyZatr0aUnS7t177J5boEABVaxY0e7ZVapU1vbtO7IcCwAAAAAAaTHGxBpjOiWXlP+fMWZFimvDjDEVjTH3GmMyNR9cjh7AlKRu3V5Sw4ZP6uLFi9na7+nTp1WhQgXb8S+//Co/v0rq1Kmj3N3d5e7urjp16qhy5co3/YxXXump0qVLy8fHRx999IFmznScQZmRfv0GyM+vimrVqq1atWpr4cJF+vHHceratZskadOmzWrTprWKFSsmy7LUqVNH5c2b1zavZUru7u6aM2eWLl26pMDArqkGcjdt2qxmzZ7W3XffLSlp/kE/Pz/t2rXbYWxvvvm2+vX7SF26BMrT01OWZemRRx7R99+PkSSNHfu9PvjgPdtgqpeXl1q3bpWqn7x586pDh/by8vJSfHy8oqKilJjo+K8B27ZtV4cO7eXm5qbGjRvL3//aYjXNmjWzLfATGRmphIQEh/2sX79eDRo8rvz582vcuPEKCQnRwYP7NW7cj1q69A/1799X69dv0Ndfj3QYw/WKFSumV17ppQED+umDDz6yva8zZ85W374fqnTp0rIsS40aNVKLFs0dzht65MgR+fs31Ecf9Ut17cCBAxo79ntNmzZZ9erVk5ubm+677z7NnTtby5Yt1/Lly1Pdk5CQoAEDBum9997J1GvISJ48eVS5cmVNnz5NJUqU0JdffpWqTWJioubOnadhw4aoUKFCcnd3V7t2z+u++6po8eIlDvsNDw/XTz+NV//+fW3n5s6dp3LlymnQoAGaNCnj7GsPDw/ly5fPtrm5Jf3osyzL7vzNLKT1999/2+a9vGry5Knq2/dDeXt7695779VLL3XTxImTbdeNiZe/v7/D/q7GlDdvXrt9Sfr3339lWZbat28ny7JUvHhxPf98W+3YsVNS0jQW1apVVcuWzylfvnzq37+fduzYabdivb//Y2m+1wAAAACQmxjJ6VmOrry5khw/gHn48GFt2bIl2/sdOfIbtW7dUufPn9XIkV8pJiZGTz31tNq1e14nTx7XqVMnNHz4J1laOTwoaIaWLl2sw4cP6NChQxo6dJjt2tXy8MyIiYnR6dOnbdulS5d04cIFhYcnlfAOHz5C27dv17ZtWxQREaY33nhNrVq1tc3RN2bMdxoz5jtJ0sMPP6wWLZrrqaeeVEREmF2pupS06viMGbO0cuVyRUWFa9Sor9S9e0+7AZKU5s6dp+ef76AXXuiqkyeP6/Tpkxo6dLAWLFgkSZo/f4GGD/9MM2ZMU2Tkee3atV1PP+14XsbOnTvpyJFDiow8rx49XlbHjo5XdX7ttTfUokUzRUSEqWPH9po/f4HtWqVK92jZst8VExOp9evXavTosVq5cqXD9zQoaIa+/vpLxcXFqVu3l1SiRGk1avSkunbtpgceeFBjxoxNNcB7vYiIMMXERGrnzm1q2vRptWnTThMmTLRdHzx4iP76a73Wrl2l8PBzGjHiE3Xs2Fm7dzseEF63bl2ac4r27t1HP/00XlOnTlJMTKSWLPlVK1euUqtWbdKMb/r0GenOUZoZzz/fVtHREYqMPK+FC39WWFiYateum2a/vXr11vnz57Vjxz86cyZUvXu/ombNntGZM2cctpekr78eqaZNn1b16tUlJU3/MHfuPJUpU0bTpgVlGOOePTt1+fIF29a1axdJ0iOPPGx3/vLlC8qTJ48k6dtvR9k+/9HREdq8eaPDvuPi4jRx4mR16tTRdm7AgIE6dOiQjh49rFWrVuizz77Q778nLZxVpkwZRUVFaefOnQ77e+yxx3T58gUtXvyLfH19dfnyBS1dmjTgGB0drZYt2+iNN15TePg5bdu2Rbt27bL97Dh37pxatWqrYcOGKDz8nOrVq6t27TrY+q5Tp45iYmJSLfYEAAAAAIArszIagPlPgrAsI+Vxdhj/qeDgg3rxxe4OM+PgGvLkyaPZs2fKzc1NQ4d+rG3btqlAgQJ69tln9O67b+vBBx+54TkwcXsqUqSI1qxZqfvvr6PLly+n27Zjxw6qWrWqPvzwo/8oumvmzJmlceMmaPFi56zYDtfwhm9/2/5XRwc7MRIAAADceglbjDF1nB2Fq3Jzy2fyeTheTwLS5SvHXObz4+7sAABXlZCQoFat2qhLl0B99dUXqlKlsmJjY/XnnyvVrl1HBi9hc+7cOVWpUi1TbTOTMXqrtGnrNMoAABRXSURBVG7d1mnPBgAAAADgZjGACaTDGKMJEybalX0DAAAAAIDbgXG5uR7hGAOYTnL33fc4OwQAAAAAAADA5TGACQBALsK8lwAAAMA1ZGDmDDl+FXIAAAAAAAAAty8yMAEAAAAAAJALGUlkYOYEDGACAAAAAABkUs8y/Wz7Y0KGODESIPdgABMAAAAAAAC5j2EOzJyCOTABAAAAAAAAuCwyMAEAAAAA2aJLib62/YmnhjoxEuDWoWz89mEkGebAzBHIwAT+v707j66yuhc+/t2AWKghTNVLMOSKgopV6YBitXrBt2VQr/UubxVQKuJYvavDFVT0VagMggoLsXUCLCIEkPtaawsOpXirgqit2BZklkDCmAYCCDgk+/0jh9MACURMck7C95N11nnGs3951m/tk/XLfvYjSZIkSZKktOUITEmSJEmSJB2FonNg1hEWMCVJkiRJ1cLbxiVJNcECpiRJkiRJko5SJakOQFXgHJiSJEmSJEmS0pYjMCVJkiRJknQUcg7MusIRmJIkSZIkSZLSliMwJUmSJEmSdJRyBGZd4AhMSZIkSZIkSWnLEZiSJEmSJEk6CkVwDsw6wRGYlYjxc04++eQjOnfy5IkUFW1l0aKF1RzV0Sk7O5udO7fToEHdSNf58+cxcOD1APTt24dXXpmb4ogkSZIkSZLqrrpRESpn587tyVdJyafs3r0zud63b58Kz7noootYv35trcR3wQUX8L3v/R9OPDGHc889r8Jjhgy5m7y8NRQXF5GbO42MjIzkvtGjH2Tduo8oLi5i7drV3H33Xfud261bN/7853coLi5i9eoV3HjjDQd9/hNP/Cq5vabbOpycnBxi/JyGDRtW+ZyPPlrFxRdfnFxfv349GRnNKS2te/8VmT49lx49eqU6DEmSJEmSVIHoT6U/6aTOFTAzMponX+vWreOyy36QXJ8+PTfV4ZGT0461a/PYvXt3hfv797+Wa6/tx/nnX0hWVjZNmjRhwoTxyf2TJk3mtNPOIDOzJd/5znfp168PV1zxAwAaNWrECy/M5sknnyYzsyVXXdWXsWMf5qyzztqvjV69ejJnztxaaUuSJEmSJEmqSXWugFmZxo0bM27cIxQUrKOgYB3jxj1C48aNadq0KXPn/o6srKzkSM02bdrQpUsXFix4k23bCtmwYT0TJoznmGOOqVJbbdq04cUXX+Af/9jCypXLuOGGgQBcf/0AJk58ivPO68rOndsZOvT+g8697LJLmTTpGfLz8/n4448ZPfohrrrqhzRp0gSAFStW7Ff8LC0t5ZRTTgGgZcuWZGZmMnXqcwC89957fPjhh3TqdHry+DPPPJPt27dTUFBQ422V16VLF959922Ki4vYtKmARx55GIA//Wk+ANu3/4OdO7fTtWtX2rdvz7x5r1FYuJmtWzfx3HPPkpmZCcCzz/6adu3a8dJLv2Hnzu0MGnTHQaM4K7v+APfffx8zZ+YyZcoz7Nixjb///QO+9a1vJfcPHjyI/Pw8duzYxrJlS+jevXuFv0+zZs2YMuUZtmzZyNq1q7nnniGEEAD40Y/688Yb/8tDD42hqGgra9aspGfPnhV+zr5j94nxc26++SZWrPiQbdsKeeyxR/c7fsCA61i69G8UFW3l5Zfn0K5duwo/V5IkSZIkVYdSX5W+0ke9KWDec88QunbtSufO3+Lss7/JOeecw7333sPu3bvp1etSNmzYkBypuXHjRkpKSvjZz/6b1q1P4LzzLuDii7vz4x/fWqW2ZsyYTn5+PllZ2Vx55VWMHDmcbt26MXnyM9xyy49ZuPBtMjKaM3TosArP31cI27f8la98hQ4dOiS33XnnYHbu3E5BwTq++tWvJkeWbtmyhenTcxkw4DoaNGhA165dycnJ4c0330qe27t3L37/+7m10lZ548ePY/z4CWRmtuTkkzsya9bzAFx4YTcAmjdvRUZGc95++21CCIwaNZqsrGxOP/3rZGdnM3TofQD073/dfiNrH3ro4Spf/33+/d8vY8aMWTRv3orf/vZ3ySJhx44duf32H9OlS1eaNWtBjx69Wbt2bYW/z4QJ48nMzKR9+w5cdFF3+ve/hgEDrkvuP/fcc1i+fDmtW5/AmDEPM2nSUxV+TkUuvfQSunTpyllnfYMf/vA/6dGjRzLuIUPu4j/+4z/52tf+hTfeeJPc3GlV/lxJkiRJkqT6qN4UMPv168MvfjGcrVu3UlhYyLBhD3Dttf0qPf4vf/kLixYtoqSkhLy8PJ588mkuuujCw7Zz4okncv753+HOO+/mk08+4YMPPmDixMn0739NleJ8+eVXuOGG68nJyaFZs2bceecgAJo2bZo8ZvToMWRkNOcb3/g2U6dOo7i4OLkvN3cm9913L598sps33nide+75v+Tn5yf3X3JJb+bMmVsrbZX32Wefccopp9CqVSs+/vhjFi1aVOk1WL16NX/4wx/49NNPKSwsZOzYcVW69lC16//mm28xd+5cSktLmTr1Oc4+u+y295KSEo499lg6depEo0aNyMvLY82aNQe10aBBA66++iruvvsedu3aRV5eHo88Mo5rr/1nG3l5eUycOInS0lKmTHmWrKwsTjjhhCr9Dg8+OIbi4mLWr1/P/Pmv07nz2QDccsvNjBo1mmXLllFSUsLIkaPo3PlsR2FKkiRJklRTYvRV2SuN1JsCZlZWFnl5ecn1vLw8srKyKj2+Q4cOvPTSi2zcmE9xcREjRw6ndevWVWqnqKiIXbt27ddW27ZtqxTn5MnPkJs7k9dfn8eSJX9l/vzXASosDC5evJg9e/YwbNhQAE499VRmzJhG//4DaNy4CWeccRaDB99B7969AcjMzOS0005lwYIFNd7WgQYOvJGOHTuwbNkS3nlnIZdcckml1+D4448nN3ca+fl5FBcX8dxzz1bp2kPVrv+mTZuSy7t376ZJkyY0bNiQ1atX89Of/pyhQ+9jy5aN5OZOo02bNge10bp1axo3bnxAPq2jbdt/5tOmTZuTy3v27AHguOOOq9LvcGB8+87LyWnH+PHj2LatkG3bCikq2koIocq5JUmSJEmSVB/VmwLmhg0byMnJSa63a9eODRs2ABArqBo//vgvWbZsOR06nEZmZkuGDLl3v9utD9VOy5Yt9ytWtWvXjoKCgirFGWNk6NBhnHTSKWRn/ytLliwlPz+/0vMbNWrEySe3B+DrXz+DFStW8OqrrxJjZMWKFfz+93Po1avsFuQePb7PH/84P/m07pps60CrVq2ib99rOP74Nowe/RCzZ8+kadOmFV77kSOHE2PkzDM7k5nZkmuu6b/fta/onH2+7PXPzZ3Bd797ETk57YkxMnr0qIOOKSws5NNPPz0gn7IpKNhQpTaO1Pr1+dx88620aNE6+WraNIOFCxfWaLuSJEmSJB2dUv2c7/T+SSeNUh1AdcnNncm99w7h3XffJcbIfffdy3PPTQdg8+bNtGrVimbNmrFjxw4AMjIy2LFjB7t27eLUU0/l1ltvZuvWwsO2k5+fz4IFCxk1agR33DGYjh07MnDgAPr161+lOFu0aEGLFi1Ys2YNp59+OmPHPsQvflFW0AshcOONNzBr1vNs376dLl26cNtttzJq1GgA3n9/MR06dKBbt27Mnz+f9u3bc+mllzBmTNk8kWXzX86plbYO1K9fX1555VUKCwvZvr3sNvTS0lK2bt1KSUkJ7du3Z+XKlclrX1xcTHFxMVlZWQwadMd+n7V58xbatz+JefOq9/p37NiRtm3b8tZbb7F371727NmTfDBQeaWlpcya9TwjRjxA//7X0bJlS37+85/y8MNjD9vGl/HEE0/ywAPDWLz4A5YuXUqzZs34/ve/x+zZ/1Oj7UqSJEmSdJR6BT6v2i2hR6fDF8pqSb0pYA4fPoJmzTL461/fB+D552czfPgIAJYvX05u7gzWrFlJw4YN6dTpTO64YzBPPfU4gwffwfvvL2bmzOfp3r3boZpI6tOnH0888Ss2bFjPtm3buP/+YcyrqNpWgdatW/PSS78hOzubrVu3Mn78BJ5+emJy/xVX/IBRo0bQuHFjNmzYwIQJv2TChMcAWLNmDddffwOPPjqOnJwciouLmTYtl4kTJwFlIzAHDbqzVto6UM+ePRg79mGaNm1KXl4eV1/dl7179wIwYsQo3nrrTxxzzDH07HkJw4Y9wLPPPkNxcRGrVq1i6tRp/OxnP0l+1qhRDzJhwnjGjHmQ4cNHHlTAO9Lrf+yxx/LggyM5/fTT+Oyzz1iwYCE33XRLhcf+13/9hAkTxrNmzUr27t3L009PYvLkZw7bxpfxm9+8yHHHHceMGdOS1/y11/5gAVOSJEmSpBoQY+yZ6hhUNeFQt+vWWhAhRDh4JJyqrkuXLjz22KOce+55qQ5FkiRJkiSlhZI/xxi/neoopC+r3syBKbj//mGpDkGSJEmSJEmqVo7AlCRJkiRJqpccgan6wRGYkiRJkiRJktKWBUxJkiRJkiRJacsCpiRJkiRJkqS0ZQFTkiRJkiRJUtqygClJkiRJkiQpbVnAlCRJkiRJkpS2LGBKkiRJkiRJSlsWMCVJkiRJkiSlLQuYkiRJkiRJktKWBUxJkiRJkiRJacsCpiRJkiRJkqS0VWMFzBBCzxDC8hDCqhDCXTXVjiRJkiRJkqT6q0YKmCGEhsAvgV5AJ6BPCKFTTbQlSZIkSZIkqf5qVEOfew6wKsa4BiCEMAO4HFhaQ+1JkiTVio4trkwur9g2O4WRSJIkSUeHmrqFvC2wvtx6fmJbUgjhphDCeyGE92ooBkmSJEmSJEl1XE2NwDysGONTwFMAIYSYqjgkSZIkSZIkpa+aKmAWANnl1k9MbKtMIZTkAa3LlqUaZ66ptphrqi3mWi1ZsW1mqkNINXNNtcVcU20x11RbUpFrObXcnlQjQozVP/gxhNAIWAFcTFnh8l2gb4xxyWHOey/G+O1qD0g6gLmm2mKuqbaYa6ot5ppqi7mm2mKuqbaYa9KRq5ERmDHGz0MItwOvAA2ByYcrXkqSJEmSJEnSgWpsDswY4xxgTk19viRJkiRJkqT6r6aeQn6knkp1ADpqmGuqLeaaaou5ptpirqm2mGuqLeaaaou5Jh2hGpkDU5IkSZIkSZKqQ7qNwJQkSZIkSZKkpLQoYIYQeoYQlocQVoUQ7kp1PKpfQghrQwh/CyEsDiG8l9jWMoTwWghhZeK9RarjVN0TQpgcQtgSQvh7uW0V5lYo82iin/trCOGbqYtcdU0luTY0hFCQ6NsWhxB6l9t3dyLXlocQeqQmatVFIYTsEML8EMLSEMKSEMJPEtvt21StDpFr9m2qViGEr4QQ3gkhfJDItWGJ7SeFEBYlcmpmCKFxYvuxifVVif3/msr4VXccItd+HUL4qFy/1jmx3e9Q6QtIeQEzhNAQ+CXQC+gE9AkhdEptVKqHusUYO8cYv51YvwuYF2PsAMxLrEtf1K+Bngdsqyy3egEdEq+bgMdrKUbVD7/m4FwDGJfo2zonHp5H4jv0auCMxDm/SnzXSlXxOfDfMcZOQFfgtkRO2bepulWWa2Dfpur1CdA9xng20BnoGULoCoymLNdOAbYBAxPHDwS2JbaPSxwnVUVluQYwqFy/tjixze9Q6QtIeQETOAdYFWNcE2P8FJgBXJ7imFT/XQ5MSSxPAX6QwlhUR8UY/wQUHbC5sty6HHg2lnkbaB5CaFM7kaquqyTXKnM5MCPG+EmM8SNgFWXftdJhxRg3xhj/kljeCXwItMW+TdXsELlWGfs2HZFE/7QrsXpM4hWB7sDsxPYD+7V9/d1s4OIQQqilcFWHHSLXKuN3qPQFpEMBsy2wvtx6Pof+40X6oiLwagjhzyGEmxLbTogxbkwsbwJOSE1oqocqyy37OtWE2xO3HE0uNxWGuaZqkbht8hvAIuzbVIMOyDWwb1M1CyE0DCEsBrYArwGrge0xxs8Th5TPp2SuJfYXA61qN2LVVQfmWoxxX782ItGvjQshHJvYZr8mfQHpUMCUatoFMcZvUjZE/7YQwoXld8YYI4f+z5h0RMwt1bDHgZMpu0VpI/BIasNRfRJCOA74H+CnMcYd5ffZt6k6VZBr9m2qdjHGkhhjZ+BEykbunpbikFRPHZhrIYSvA3dTlnNdgJbAnSkMUaqz0qGAWQBkl1s/MbFNqhYxxoLE+xbgBcr+aNm8b3h+4n1L6iJUPVNZbtnXqVrFGDcn/kguBZ7mn7dSmmv6UkIIx1BWUJoWY/x/ic32bap2FeWafZtqUoxxOzAfOI+y23UbJXaVz6dkriX2ZwL/qOVQVceVy7WeiSkzYozxE+AZ7NekI5IOBcx3gQ6Jp8A1pmxy7t+mOCbVEyGEr4YQMvYtA98H/k5Zjv0ocdiPgBdTE6Hqocpy67dA/8TTBrsCxeVux5S+sAPmSLqCsr4NynLt6sRTVE+ibGL4d2o7PtVNiXneJgEfxhjHlttl36ZqVVmu2bepuoUQvhZCaJ5YbgJ8j7I5V+cDVyYOO7Bf29ffXQn8MTHyXDqkSnJtWbl/AAbK5lot36/5HSpVUaPDH1KzYoyfhxBuB14BGgKTY4xLUhyW6o8TgBcS8243AqbHGF8OIbwLzAohDATygB+mMEbVUSGEXODfgNYhhHzgfuBBKs6tOUBvyh46sBsYUOsBq86qJNf+LYTQmbJbedcCNwPEGJeEEGYBSyl7yu9tMcaSVMStOul84Frgb4k5vACGYN+m6ldZrvWxb1M1awNMSTy1vgEwK8b4uxDCUmBGCGE48D5lBXUS71NDCKsoe4De1akIWnVSZbn2xxDC14AALAZuSRzvd6j0BQT/mSRJkiRJkiQpXaXDLeSSJEmSJEmSVCELmJIkSZIkSZLSlgVMSZIkSZIkSWnLAqYkSZIkSZKktGUBU5IkSZIkSVLasoApSZIkSZIkKW1ZwJQkSZIkSZKUtixgSpIkSZIkSUpb/x+edN4YDIbErwAAAABJRU5ErkJggg==)
"""